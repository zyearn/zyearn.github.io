<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[]]></title>
  <link href="http://zyearn.github.io/atom.xml" rel="self"/>
  <link href="http://zyearn.github.io/"/>
  <updated>2021-01-28T22:38:08+01:00</updated>
  <id>http://zyearn.github.io/</id>
  <author>
    <name><![CDATA[Jiashun Zhu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[2020感想]]></title>
    <link href="http://zyearn.github.io/blog/2021/01/03/2020-thoughts/"/>
    <updated>2021-01-03T22:17:58+01:00</updated>
    <id>http://zyearn.github.io/blog/2021/01/03/2020-thoughts</id>
    <content type="html"><![CDATA[<h2>2020感想（一）于 2020-12-30 19:11</h2>

<p>从上周就开始了两周的假期，每年的最后一周的主题总是反思和放松，并和过去几年一样，不准备写类似「年终总结」的东西，主要是因为写这个东西实在太累了，无法长期坚持，一想到要回顾一整年，感性上就觉得任务量巨大，能拖就拖吧，于是就拖了一年又一年。就算开始写了，也很难保证它真的是年终总结，生活中有无数的小事在塑造和影响着我们，而这些在年末的时候可能都想不起来了，留在我们记忆中的都是宏观意义上的大事。就算把每件事都写下来了，这些事之间很难有关联性，因为文章的时间跨度是一年，发生在一年内的事情并不代表有关联，于是作为作者需要起承转合来连接这些事情，也构成了写作一大难点。</p>

<p>从读者角度，要看作者一年的信息量，尤其是在赶上了这个年末各种总结堆积的时间，带来的结果是很难让读者认真地去看。</p>

<p>However，年终总结还是有好处的，最大的一个好处是当你和你做的事情、经历的事情保持了一定的距离以后，当初的情绪和冲击早已经烟消云散，能不被当初那个旋涡所带走，而是以一个第三方的视角来重新审视一件事，得到更加客观的视角，从而在事件中成长。</p>

<p>于是我就想了一个折中的办法，写「年终想法」，这是第一条，未来一周正好休假，写到哪算哪，没有任何负担，也不知道会写几条，可能这是第一条也是最后一条。如果刚好能写了4、5条那拼起来「年终总结」也就完成了，同时也不费心费力，正好尝试下。</p>

<p>（原文链接：<a href="https://www.zhihu.com/pin/1327798716515176448">2020感想（一）：从上周就开始了两周的假…</a>）</p>

<h2>2020感想（二）于 2020-12-31 11:54</h2>

<p>写作是一个很神奇的东西，当我在写（一）的时候，接下来的二三四大概写什么已经有一些模糊的主题了。</p>

<p>关于年终总结，再多写几句。本质来说就是总结和反思，而反思这件事情的时间跨度不能拖太久。以产品为例，如果一个产品从设计到原型到实现到测试上线，如果整个过程花一年的时间，过程中没有任何反馈，上线后必然会面对大量预期落空。合理的方式是从小开始，快速上线一个想法原型，得到一个反馈，调整后再得到反馈，在这个循环中不断改进自己的产品。年终总结也是如此，我比较推荐的方法是每隔一小段时间（具体时间因人而异）就花很小的精力做一下，做迭代式的总结和反思，这样不仅省事，也能及时调整，免得一年后才发现这件事原来有更好的做法。</p>

<p>第二点是人往往会陷入时间的陷阱，觉得在2021要有什么计划要做什么事情，当然这并没有什么问题，只是这些事情并不用等到2021才可以去做，时间是一个人类发明的概念，而真实的世界只有此时此刻，这一秒和下一秒没有任何区别。好好生活在当下，过好每一分每一秒，做好手头上的事情，做好生活中细微的小事，不过分担心还没有发生的事情。不要期待时间能改变什么，时间本身改变不了任何事情，是我们当下微小的努力、行动和思考，以及这些行动的反馈和结果，在慢慢改变我们自己和这个世界。</p>

<p>（原文链接：<a href="https://www.zhihu.com/pin/1328051145282093056">2020感想（二） 写作是一个很神奇的东西…</a>）</p>

<h2>2020感想（三）于 2020-12-31 16:23</h2>

<p>2020对我而言最大的变化是休了三个月的长假，然后换了一个国家生活，来到了瑞士，加入了Google。</p>

<p>先来说说这三个月的假期，我一直觉得人一直处于工作状态不是一件理所应当的事情，比如在默认状态下，没有一些不可抗力的存在（如因生病必须离开工作），那么会期待这个人一直工作直到退休的年纪。我想尝试一下另外一种方式，工作了一段时间后，在基本了解自己过去几年在玩一个什么样的游戏后，短暂性地和自己所做的事保持一个距离，或者离开职场一段时间，用来总结、回顾和休息。有点类似导演、作家、艺人的做法，我相信导演也不是一年三百六十五天在持续地拍电影，而是有好的剧本有好的机会就集中一段时间把电影拍出来，然后需要长时间得思考和调整，甚至过好几年后再拍下一部电影。于是我就给自己了一个三个月的假期什么正经工作都不做，并用来思考一些根本性地问题，包括不限于：</p>

<ul>
<li>我在做目前的工作是因为真的喜欢还是因为惯性？</li>
<li>如果生命还剩下一年的时间，我是不是还会做目前这件事？（真实情况是可能还剩下50年左右）</li>
<li>我到底在追求什么，如果按照之前的轨迹发展下去，会取得我希望的结果和目标吗？</li>
</ul>


<p>当然我也深知这个“短暂离开职场”是一件有风险且需要勇气的事情，有太多世俗意义上的得失需要去考虑，并不是每个人都适合。</p>

<p>在这三个月离开职场的日子里，也发现了一些平时在职场中没有遇到的问题：</p>

<ul>
<li>无论是上学还是职场、都是在一个平台之上做事情，如果离开职场后，没有一个做事情的平台，怎么持续地给自己找一些感兴趣的事情去做？</li>
<li>很多朋友都是因为某种工作场合才认识的，在脱离了这个环境后，会重新思考自己的社交能力</li>
<li>没有老板、没有组会、没有OKR/KPI，怎么驱动和提升自己？</li>
<li>怎么判断自己的方向是不是偏了？在公司里，大家做决策可以一起review一起商量，如果走歪了也比较容易发现，而自己一个人创业/做事情，得到反馈的时间就会比较长</li>
</ul>


<p>这些问题我猜也都是自由职业者考虑的问题，所以我也或多或少地了解了一些自由职业者面临的一些难处和困境。总之，这三个月给了我很大的调整自己的空间和思考时间，以及有时间认真思考一下这几年决策和做事的方法。结束了这段时间后，我就踏上了瑞士之旅。</p>

<p>今晚正好是跨年夜，祝大家元旦快乐。</p>

<p>（原文链接：<a href="https://www.zhihu.com/pin/1328118871102799872">2020感想（三） 2020对我而言最大的变化…</a>）</p>

<h2>2020感想（四）于 2020-01-02 13:45</h2>

<p>这篇来写已经在国内工作了几年后，选择出国工作的想法和初衷，不会涉及过多的国外工作的体验，可能要再等一段时间才有能力来写这个话题。</p>

<p>在写下面这些文字前，由「历史往往是成功者来撰写的」类比，当下的自己是过去所有自己的成功者版本，由当下的那个自己来写下过去无数的自己所做的事情和做的决策，很可能会有很多“历史改写”以及无意识的偏见。人是一个很会自我欺骗、自我编故事的动物，所以我尽量以客观、真诚的视角来写作，不然就没意义了。</p>

<p>随着对自己认识的加深，我发现自己是一个「经历派」，想要在还年轻的时候去体验一下不同的生活和经历，于是抱着对不同文化的好奇，我决定尝试一下在一个不同的国家生活。另外我们做的几乎所有事的副作用都是在「自我探索」，在工作、学习、交流、讨论的时候进行自我观察：为什么我会有这个感觉，为什么会觉得别人冒犯到我了，我怎么会对这件事生气/开心。一切事情都是了解自己的一个机会，我又是一个比较喜欢自我探索的人，而把自己扔到一个新奇的、陌生的、甚至是困难的环境中去，没有比这个更能探索自我的事情了。</p>

<p>至于这个体验是好是坏，很多时候并不由我们自己决定。我是在欧洲的第二波疫情还没有爆发的时候过来的，此时每天新增的数字还在有效的控制范围中，还幻想着欧洲的疫情终于缓下来了，之后可以恢复正常的生活。结果后来我们都知道了，欧洲迎来了第二波猛烈的爆发，并且一直持续到了现在，也打破了我一周偶尔可以去办公室的节奏，瑞士疫情也更严重了，又进入了全面WFH（work from home）的阶段。对于我而言，这无疑是一个坏消息，一部分同事还没有线下见过面，这段时间的WFH经历告诉我，人是需要线下见面的，这样信任感才能慢慢建立起来，这也是对所有新入职同事的挑战和困难。</p>

<p>随着第二波疫情的到来也打破了我对很多事情的期待，比如之前计划着去周边国家的旅游，而现在的情况是边境也封锁了，英国的病毒变异的新闻又是连连不断，自己待在家里是目前最好的选择，实在想出游的话只能先在瑞士境内探索，好消息是瑞士有很多风景胜美的地方可以去。</p>

<p>Google的工作环境目前给我最大的感受是大家是在一个「心理安全区」（Psychological safety）的共识下工作的，就是鼓励大家问问题，鼓励大家把心里的困惑说出来，即使是显而易见的问题，也不用担心评价、批评或惩罚。我的同事第一周就把「冒充者综合征」（imposter syndrome）的心理现象分享给我，意思是大家或多或少在某个时刻会觉得自己不应该在这里工作，害怕别人发现自己是个冒充者而已，告诉我如果我现在或以后有这种想法的话，可以聊一聊。</p>

<p>在感想（三）里有些同学留言问想去面试需要准备什么，在这里做个调研，如果大家想看的话留个言或者给我发个私信，需求比较大的话我抽时间写几篇独立的文章。</p>

<p>不过相比如何面试，一个更重要的问题是「自己为什么要离开现在的环境」，我想特别说的一种情况是不要为了逃避而选择另一条路。一部分同学刚毕业不想工作，于是逃避工作去读研究生、结束仍后不知道干什么，逃避去读个博士了，我不是说读研读博本身不好，而是它们的动机问题；工作了发现自己不喜欢，逃避到另外一份工作，这种逃避式的换环境并不会解决问题，同样的问题在另一个环境中还会出现。或许我们生命中都会面临这种场合，觉得自己被什么东西困住了，这个东西可能是你的家庭、是你的工作、是你的婚姻，想要逃出去，去寻找那个“我真正喜欢的东西，我真正适合的东西”，于是我们不断地向外求，这种逃避并不会解决问题，手里拿着同样一个剧本，只不过演员换了而已。当我们发现换一个环境问题没有得到解决，会更加绝望。希望大家都可以在当前的环境中解决问题，而不是以引起问题的方式解决问题。</p>

<p>写到这里篇幅差不多了，之后有机会再写一些在这里生活和工作的其它感受。</p>

<p>（原文链接：<a href="https://www.zhihu.com/pin/1328803982852894720">2020感想（四） 这篇来写已经在国内工作…</a>）</p>

<h2>2020感想（五）于 2020-01-02 20:18</h2>

<p>不出意外的话，这应该是这个系列短文的最后一篇了，简单写一写自己在这一年的一些心态变化。</p>

<p>说到心态，我慢慢意识到人生很大程度上是一个心态游戏。人是一个喜欢做自我批判的动物，类似的想法比如「这件事我是做不好的」，「别人一定会觉得我这件事做得很差劲」、「别人背地里一定是在嘲笑我的」经常出现在人们的心中，变成自己进步和做事的阻碍。结合我自己的经验我想说得是，首先这些都不是真的，都是一些主观扭曲化后的想法，完全和现实违背；其次，不用在乎别人是怎么想的，无论你做得好做得差，总有人议论你。耐心地做好自己的事情，从小事慢慢积累自信。If you want to win like a champion, you have to think like a champion.</p>

<p>另外，在这一年结束后明显觉得自己变柔软了，更有同情心了。对于一些人和事，也不会再去评判了，人往往容易在不了解事情全貌的情况下给出自己主观的判断、甚至是偏见。举个例子，如果一个人如果支支吾吾一个问题解释不清楚，人会下意识地认为是不是ta的水平问题，而真实的原因可能是因为某人在某次交流中批评了ta，导致ta在那个人面前说话就格外得害怕和紧张，还是一个心理问题而不是水平问题。</p>

<p>然后也明确了未来几年不断去寻找的、对我重要的东西：知识、眼界、思维方式、有益于双方的人际关系、偶尔彻夜的长谈交心、人与人之间真实的连接感、让人难忘的体验、保持身体健康和心情愉悦。</p>

<p>自己也慢慢放弃了对「确定性」这件事的执著，以前总是希望做事之前要有明确计划，要知道自己在干什么，而过去一整年的经历劈头盖脸地告诉我们，力所能及地做计划，做好当下的事才是最重要，至于未来怎么样，除了随机应变很难想到别的方法。我们都是在迷雾中行走，没有指南针没有地图，唯一能做的是摸索前进的同时，照顾好自己以及身边的人，thrive in ambiguity。</p>

<p>好了就写到这吧，在写这个系列之前犹豫过要不要写，不过在这个如此混乱无序的世界中发出自己的信号总是没错的，可能会对某些人有所帮助，也可能找到同类的人。祝愿看到这里的大家在未来的时间里，不要放过自己向这个世界发出信号的机会，找到志同道合的伙伴，在不平凡的一年过好我们平凡细微的生活。</p>

<p>（原文链接：<a href="https://www.zhihu.com/pin/1328902807919886336">2020感想（五） 不出意外的话，这应该是…</a>）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[brpc在SDK灵活性方向的实践]]></title>
    <link href="http://zyearn.github.io/blog/2020/02/29/brpc-sdk-flexibility/"/>
    <updated>2020-02-29T18:29:00+01:00</updated>
    <id>http://zyearn.github.io/blog/2020/02/29/brpc-sdk-flexibility</id>
    <content type="html"><![CDATA[<p>如果有关注到brpc最新支持功能的朋友可能已经发现了，brpc在最近支持了redis server端的协议（redis client早已支持），使得brpc server可以接受来自redis client的命令，处理，并返回结果。通过实现brpc提供的命令回调函数，理论上完全可以用brpc来实现出一个redis server，但这并不是支持这个功能的初衷，我们的初衷是通过这个功能来解决SDK灵活性的问题。</p>

<p>什么是SDK灵活性问题？想象这样一个场景：你正在为公司开发一个新系统，目前已经完成系统的基础功能，并对外发布SDK1.0，让公司内不同的团队可以接入你的系统。为了支持更多功能，会对系统进行迭代开发，此时SDK2.0就发布了，这会带来几个问题。</p>

<ul>
<li>问题一：只要基本功能满足要求，不需要用到新功能的用户还会因为稳定性等原因继续使用老的SDK1.0，如果升级是不兼容的，就会使得你需要维护两个版本SDK的系统实现，随着时间的推移维护的版本越来越多。</li>
<li>问题二：有些升级仅仅是对服务方有收益，例如为了更好地监控系统节点在客户端的表现，需要在SDK加入了统计上报的功能，这对用户没有直接的提升，用户会继续使用旧版本SDK，导致统计数据收集困难。</li>
<li>问题三：当一个新功能需要升级SDK才能用，会引入额外的尝试成本，降低了用户尝试的可能性，导致新功能的推行困难。</li>
<li>问题四：某些复杂的SDK还会加入负载均衡、重试、熔断限流等逻辑，如果这些逻辑发生了改变、升级或是bugfix，那么用户也必须显式地升级SDK。</li>
</ul>


<p>一个灵活的SDK可以在server端升级功能时，客户端的SDK不需要变化就可以直接新功能。redis提供了一种很好的思路，这里首先给不熟悉redis协议的朋友介绍一下它的基本原理。在redis-cli中输入set foo bar后，客户端并不会解析这条命令，而是把用户的输入完整地传给server端，当server解析第一个字符串发现是set后，就会调用对应的处理函数，最后返回结果给客户端。如果延用这种想法，那么就可以在server升级时SDK不需要更改就可以使用新功能。对于用户而言，只要输入最新功能对应的命令即可，没有升级SDK所带来的成本。另外，由于SDK本身并不解析命令，只负责传输，就不存在前文所说的因升级而维护多个SDK系统实现的问题。</p>

<p>为了实现这种想法，brpc需要一套类似的协议，并且SDK需要满足如下几点：</p>

<ul>
<li>具有普遍性，每个语言都有完整且正确的实现</li>
<li>具备可维护性，最好不由brpc团队来维护，由第三方/社区来维护</li>
<li>具备低学习成本，甚至用户可以一看就会</li>
</ul>


<p>我们发现redis协议天生就满足上述三点：</p>

<ul>
<li>redis client在各个语言中都有比较完整和正确的实现</li>
<li>redis client由各自语言的社区来维护</li>
<li>redis是事实上的缓存系统，其开发者对其接口很熟悉，即使不熟悉也可以迅速通过已有的广泛资料学习。</li>
</ul>


<p>如果brpc能直接支持redis server协议，就能实现上述所讨论的灵活SDK，于是就开始设计和实现，并在最近将一个稳定高效的实现合并到了主干。想尝试这个功能的话已经可以拉最新的master代码，阅读redis.h中的注释文档来构建一个redis server。</p>

<p>在实现中尝试了很多性能优化，这一段来简单说一下。熟悉redis的朋友都知道，消息会在server端按序处理，然后按序返回，而一些二进制协议则没有这种要求，这使得server端可以对这些请求进行并发，一个典型例子是http2.0，序列化的时候会带上一个stream_id，在server处理完消息后会将这个stream_id一并返回，从而使客户端可以找到该rpc的上下文。在实现中遇到的一个主要问题是是否要给redis命令的函数回调支持异步接口，如果支持异步接口，框架层面会递给用户一个回调对象done_closure，在用户做完所有操作后，调用done_closure.Run()就可以了，这种写法的好处是server端的消息处理可以是并发的，对消息不需要严格按序处理的场景可以受益，但由于用户可能随时调用done_closure.Run()，而客户端又要求消息按序返回，框架层面需要提供一种队列机制，后面到达的请求如果先处理好了，就需要等前面的请求处理好了发送出去后，才能发送出去。这种方法虽然灵活性很好，提供了异步接口可以并发，但是框架需要额外的维护成本，在实测中，性能并不是很好。第二版本放弃了异步接口，强制要求所有的消息需要顺序执行，实测中表现非常好，在绝大多数的场景单链接上只有一条消息，这种方式是可以接受的。另外考虑到现实中导致并发处理的往往是batch命令，例如在redis中多条命令同时到达server，针对这种场景，做了一个优化：递给用户一个bool变量表示是否是一批中的最后一个，用户根据这个变量来缓存消息（对应bool值为false）或是批量处理消息（对应bool值为true）。我们在开发中还进行了大量编码上的讨论，由于篇幅限制，更详细的可以看[1]。</p>

<p>听起来好像很完美了，客户端发送任意命令，服务端根据命令解析。然而实际场景中会遇到几个问题：</p>

<ol>
<li>由社区/官方维护的redis client一般没有重试功能，更别说根据业务返回的结果进行按序重试了，同时也缺少了一些高级的功能，例如熔断、限流、不同的负载均衡策略等。</li>
<li>已经开发完成的legacy系统一般通过http/h2+pb/json对外提供服务，是不可能为了支持这个功能而用brpc重写的。
计算机科学中遇到的所有问题都可通过增加一层抽象来解决（但抽象不是越多越好，一个好设计是没有多余抽象的，只留下必须的抽象）。为了解决上述问题，可以增加一个brpc redis proxy来加一层抽象，在这个proxy中实现负载均衡、容错等功能，并把请求翻译成系统本身的SDK命令，下图是一个高度抽象的架构图。</li>
</ol>


<p><img src="http://zyearn.github.io/images/proxy.jpg" alt="proxy" /></p>

<p>为了更好地理解，这里介绍一个可能的应用场景，在一个分布式key-value系统中的应用。这类系统一般的实现中包含一个metaserver集群，和数据节点集群，如果采取用户通过SDK方式来访问系统，这里做的事情简略来说是先访问metaserver得到数据节点分布等元信息，然后通过某种负载均衡的方式来访问数据节点，如果数据节点访问错误还得做重试，即使节点没挂，也会据业务层的错误码判断是否重试，总之这是一个非常复杂的SDK。如此复杂的SDK还得为每个语言都写一套，很难保证所有语言在某些逻辑上是完全一致的，不仅如此，多套语言的SDK的背后往往意味着巨大的维护成本。</p>

<p>作为解决方案，用brpc写一个redis proxy来做转发，从开发者的角度来说，只需要写一套C++ SDK然后集成到proxy中即可，大大减少了维护的成本和难度。由于SDK的功能全部下沉到了proxy，原来需要业务方升级SDK来支持的功能（如统计上报，改变重试策略等）也可以不依赖于业务方。从系统的用户角度来说，使用新功能的成本大大降低，并且不需要引入一个那么复杂的SDK也保证了程序的正确性和稳定性，SDK使用方式的学习成本也变低了。</p>

<p>在上述的分布式key-value系统的例子中引入了proxy后，还可以玩一些花哨的东西，比如自动缓存。在cache-aside缓存系统里，用户需要和数据库和缓存交互，很容易写出一些竞态的代码[2]，而如果将缓存隐藏在proxy后，那么就可以将这部分涉及到更新缓存的代码下沉到proxy，大大减少了业务开发同学的心智负担，只需要像访问单机一样就可以访问缓存+DB的存储系统。</p>

<p>系统设计包含大量的取舍（tradeoff），不会存在一种在每个方面完胜的设计，使用brpc redis proxy也不会是银弹。例如，请求和回复都在proxy上做了一次停留，或多或少会引入延迟，带来一些性能上的消耗。若真的对性能有较高的要求，在部署上可以采取sidecar模式，优点是性能与使用原生SDK几乎是一样的，缺点是依然需要业务方去主动升级，但总比更换SDK方便一些。</p>

<p>总结
在本文中，分析了传统发布SDK的问题，提出了一种在brpc中实现灵活SDK的解决方案，讨论了实现中的取舍，并在一个应用场景中讨论了使用方式和效果。</p>

<p>Reference:
[1] <a href="https://github.com/apache/incubator-brpc/pull/972">https://github.com/apache/incubator-brpc/pull/972</a>
[2] <a href="https://coolshell.cn/articles/17416.html">https://coolshell.cn/articles/17416.html</a></p>

<p>感谢戈君、陈章义对本文的审校。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABtest数学原理]]></title>
    <link href="http://zyearn.github.io/blog/2019/05/22/how-to-judge-effectiveness-of-exp/"/>
    <updated>2019-05-22T14:19:00+02:00</updated>
    <id>http://zyearn.github.io/blog/2019/05/22/how-to-judge-effectiveness-of-exp</id>
    <content type="html"><![CDATA[<h2>问题</h2>

<p>假设现在有一个新的点击注册文案，想要测试它的效果，实验人员将实验分为对照组和实验组，给对照组看原来的文案，而给实验组看新的文档。实验结果是，对照组中的14500人中有1450人注册点击，而在实验组的14500人中有1600人点击注册，如何通过实验数据来判定新的文案是否优于老的文案？</p>

<p>主要看两个指标：第一个是实验是否统计显著（statistically significant）；第二个是统计功效（statistical power）是否满足。</p>

<h2>统计显著</h2>

<p>首先看实验是否统计显著，即pvalue是否小于显著性水平，使用的方法是假设检验。具体方法是当零假设（两个版本没有区别）成立时，算出得到观测数据的概率pvalue，如果这个概率小于显著性水平，则拒绝零假设，实验结果显著。pvalue具体计算方式如下：
假设p1,p2为两个版本的总体点击率，对控制组的样本均值设为X1bar，实验组的样本均值为X2bar，根据中心极限定理，X1bar和X2bar均满足正态分布。根据<a href="https://en.wikipedia.org/wiki/Sum_of_normally_distributed_random_variables">两个独立正态分布变量之和依旧是正态分布</a>，X1bvar-X2bar也满足正态分布。于是有
<img src="http://zyearn.github.io/images/distri.png" alt="avatar" /></p>

<p>然后建立零假设p1-p2=0，并计算z-score，如果z-score大于显著性水平所在的临界值，那么就拒绝原假设，即p1不等于p2。这里需要注意的是，就算拒绝了原假设，它也是有概率成立的，只是这个概率太小，一般显著性水平alpha设置在0.05，那么只能说95%的概率原假设是不成立的。如果pvalue小于alpha，但是真实结果是p1等于p2，这类错误叫做第一类错误，让alpha的值较小可以降低这类错误的发生。</p>

<h2>统计功效</h2>

<p>第二个指标是统计功效。需要让这个指标达标，样本数量需要满足一定的要求。在实验开始前，先计算每个实验的分流数，让实验经过那么多流量后，该实验的统计功效才能得到满足，分流数的计算方法为(来自<a href="http://www.evanmiller.org/ab-testing/sample-size.html">http://www.evanmiller.org/ab-testing/sample-size.html</a>)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">num_subjects</span><span class="p">(</span><span class="nx">alpha</span><span class="p">,</span> <span class="nx">power_level</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">delta</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">p</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">p</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="nx">p</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">t_alpha2</span> <span class="o">=</span> <span class="nx">ppnd</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="nx">alpha</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">t_beta</span> <span class="o">=</span> <span class="nx">ppnd</span><span class="p">(</span><span class="nx">power_level</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">sd1</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">p</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="nx">p</span><span class="p">));</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">sd2</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="nx">p</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">p</span> <span class="o">+</span> <span class="nx">delta</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="nx">p</span> <span class="o">-</span> <span class="nx">delta</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="nx">t_alpha2</span> <span class="o">*</span> <span class="nx">sd1</span> <span class="o">+</span> <span class="nx">t_beta</span> <span class="o">*</span> <span class="nx">sd2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">t_alpha2</span> <span class="o">*</span> <span class="nx">sd1</span> <span class="o">+</span> <span class="nx">t_beta</span> <span class="o">*</span> <span class="nx">sd2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nx">delta</span> <span class="o">*</span> <span class="nx">delta</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中alpha为显著性水平，power_level是功效值，p是控制组基准值，delta为实验的最小差异。当实验经过那么多流量后，如果统计显著，那么该实验就是可信的；如果统计不显著，我们要确保这两个版本确实没有足够大的差异，即接受零假设p1=p2，此时会发生的一种情况是，p1不等于p2，只是这次实验中，p1-p2的值刚好落在假设检验的接受域中，这类错误称为第二类错误（接受了错误的原假设）。为了让第二类错误足够少，可以让p1-p2这个正态分布足够窄，那么落在Z_alpha之内的值的概率就足够小，此类情况的概率就足够小。</p>

<p>在以上两种指标都达标时，当实验结果显著时，它大概率就是显著的（显著性水平保证了第一类错误小于5%）；当实验结果不显著时，它大概率就是不显著的（统计功效保证了对这个不显著的结果有多大的信心）。</p>

<p>实验组和控制组还可以计算置信区间，表示总体参数的范围。置信区间有两种解释方式。
第一种是计算一个结果本身的置信区间，比如Click/Impression=10/10000，那么它的置信区间为0.001±sqrt(0.1*0.9 / 10000)
第二种是计算某组相对控制组的提升百分比置信区间，我们采取这种方式展示。</p>

<p>不仅要看最终是否显著，还需要看趋势：试想有一个改进在白天可以提升100%，而在夜晚下降了20%，如果只看最终的结果，那么一定是显著的，但是通过看趋势我们完全可以看到晚上的异常值，从而更细粒度地发现问题。</p>

<h2>实验方法论</h2>

<ul>
<li>根据alpha、power_level、p、delta计算出实验最小分流数（若知道pv，则可以算出实验时间），这个计算需要用户自行用工具计算（很多在线工具）</li>
<li>设置实验参数、上线实验</li>
<li>实验期间观察关键指标的变化趋势，看是否有大起大落等异常现象</li>
<li>经历了最小分流数后，实验结束，看实验是否显著（pvalue小于显著性水平）。如果显著，则较有信心改进版会有提升；若不显著，则改进版可能真的没什么效果</li>
<li>置信区间表明了上线后提升的范围</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2017工作小感]]></title>
    <link href="http://zyearn.github.io/blog/2018/02/12/2017-summary/"/>
    <updated>2018-02-12T18:23:00+01:00</updated>
    <id>http://zyearn.github.io/blog/2018/02/12/2017-summary</id>
    <content type="html"><![CDATA[<p>过去一年在百度学习了很多，踩过一些坑，也成长了很多，非常感谢帮助过我的人，这篇主要分享下自己的一些思考和想法，也和大家共勉。</p>

<p>1.保持持续学习</p>

<p>这一点永远是老生常谈的问题，任何行业任何职业都需要不断学习，像迭代产品一样进行自我迭代，这一点非常重要。而且好消息是，就我个人经验而言，如果把获得作为y轴，学习的付出作为x轴，这条曲线不是线性的，是一条斜率越来越大的曲线，也就是说已经跑起来的人会跑得越来越快。由于知识通常是有关联的，并且具备迁移性（一个思想可以在多个问题里使用），所以在相同努力的情况下，你原本学得越多，那么收获会越大。这听起来像投资，其实学习本身就是投资，可以形成利滚利。如何衡量学习的成果？让自己的速度跟上摩尔定律，即每18个月自己的综合能力需要翻倍。</p>

<p>2.深入思考以及持续深入思考的能力</p>

<p>这个世界上有很多会深入思考的人，但能持续性地深入思考是一个非常稀缺的品质。我自己也在不断地练习，我通常做法是自己和自己辩论，自己怼自己：这个设计/功能为什么要这么做？为什么不那样做？那样做的话有什么潜在问题，需要处理什么tradeoff，这个做法是最好的了吗，有没有更好的？另外一个练习是我会在碎片时间把脑子里queue里面的问题拿出来思考。一个广为流传的“好做法”是用碎片时间来阅读，但这个做法并不适合我，碎片时间根本读不进书，读书需要大片成段的专注时间，还需要做笔记，这还不是主要原因，更重要的是我需要大量的时间来把我之前的输入内化成自己的东西，碎片时间刚好可以做这件事情，很多时候我在地铁/健身/洗澡/散步的时候把某个问题想清楚了，这种体验非常好。另外还有一点，做技术的同学通常都很认真敬业，同时也很容易沉浸于技术的海洋中，但这个世界是紧紧互相联系的，读各种各样的书，然后思考各种类型的问题能让自己的思路开阔很多。对于一个问题自己心里有了一个初步的想法，觉得暂时想不出什么了的时候可以去干别的事了，下一次再想到这个问题的时候，可能就会有一个比较清晰的思路了。</p>

<p>3.学会写工业级代码，即高质量的代码设计和高性能高稳定的代码实现</p>

<p>我从去年年初至今参与了<a href="https://github.com/brpc/brpc">brpc（百度内部的rpc框架，现已开源）</a>的开发和维护工作，代码实现和抽象能力进步了很多。一个self-contained例子是，有一次需要给brpc加QueryRemover的支持：给定一个QueryString，能通过迭代器的方式来遍历key，然后决定是否删除当前的key，遍历完后返回修改后的QueryString。用naive的方式要实现这个功能其实很简单，但这不是我们追求的，这里要考虑的是：各种corner case/错误输入的处理，内存分配做到最优，性能尽可能好，当什么key都不删除的情况下应该任何内存都不分配的。最后改了几次以后代码变成了<a href="https://github.com/brpc/brpc/blob/master/src/brpc/uri.cpp#L425">这个样子</a>。现在再回过头来看这段代码，脑子里已经不再是当初naive的想法了，而是intuitively这应该就是这么实现的。类似的例子还有很多，当自己已经尽全力写好一段代码但还是被code review打回，这是一件很好的事情，因为这说明要么是自己，要么是对方还有一些不知道自己不知道的东西存在，无论是哪种情况都会对一方产生正面的作用。看代码也是一个很好的学习方式，就我个人经验来说盲目地看代码很容易坚持不下来。一种理想的方式是项目中用到了某种技术，正好需要用到/借鉴某个开源代码，然后趁热打铁有目的地去学习源码会容易很多。怎么看代码也是有技巧的，先在脑子里想一下让自己来实现会怎么做，难点记下来，然后再去看代码作者怎么做。例如我前面提到的QueryRemover，有兴趣的朋友可以想一下让你来做会怎么做，然后看一下我们的实现。目前brpc有许多<a href="https://github.com/brpc/brpc/issues">known issues</a>需要开发和解决，欢迎大家领一个走然后给我们提pr :)</p>

<p>4.区分问题的表象和root cause</p>

<p>发现了一个bug，调试发现是某个模块A报的错，那这个bug的表象就是出在模块A，但有些时候root cause可能不出在模块A，真正的原因是模块B中一个已经隐藏了很久的race condition，甚至可能是一个kernel bug。而如何提高这个区分能力，一方面在于经验，更重要的一方面在于调试能力。调试其实是有一套固定流程/方法论的，首先分析现象（问题的表象），复现bug，如果是一个随机出现的bug，那就加大压力，给系统造成瓶颈，增加bug出现概率（减小工作线程数也可以给系统造成瓶颈，但不推荐这种做法，因为如果这是个多线程bug，那减少线程会降低bug出现的概率），竭尽所能以后如果还是无法复现，那就带log去线上去复现，等复现的时候要抓住现场，然后解决问题，再次上线验证，最后总结bug。每一次bug，特别是线上问题，都是一个很好的总结反思的机会，一定是流程上的某一环节出问题了。</p>

<p>5.对问题/数字敏感，一个优秀的开发者一定是敏感的</p>

<p>我的工作导师<a href="https://github.com/jamesge">jamesge</a>曾经和我说，一个程序在control<sup>C</sup>退出的时候只要卡了一下下，就一定是哪里出问题了。还有类似的问题比如请求超时，很容易想到的解决方案是把超时时间调长，但某些情况下这只是掩盖了问题，如果有些本来应该很快返回函数处理地慢了一些，必有猫腻。不要拖，立刻去找到root cause，否则就是为以后埋坑。</p>

<p>6.锻炼抽象代码的能力，代码要尽可能低耦合高内聚，易拓展易维护</p>

<p>如果来了一个超紧急功能，我更倾向于的做法是好好评估一下，加下班做好代码抽象，而不是先粗糙实现然后加个TODO: refine this code，大部分情况下就渐渐就忘记了，变成以后的技术债了，更何况通常也不会有这种“今天开发明天上线”的需求。从软件开发的一开始就要保证每一次代码CheckIn都是高质量的，做好规范，一次写烂了就会发生第二次，然后慢慢地整个项目里都是烂代码，这就是破窗效应。在过去几年我C++写的比较多，以前有一段时间以为，功能本身的实现是需要关注的东西，而现在的观点是功能本身实现是开发中最基础最简单的东西，难的是代码抽象、性能压榨和对象的生命周期管理。另外不能偷懒，该重构的地方就立刻去重构，目的是降低代码的复杂度。让代码易维护的核心在于降低复杂度，这是一个很大的topic，推荐看《代码大全2》，最好的一本讲如何写好代码的书。</p>

<p>7.对自己设置高标准</p>

<p>曾经看到一个说法，叫面向离职编程，不是让你离职，意思就是说，你要把你的每一次代码提交，文档撰写、团队讨论都要以像在交接工作的态度来完成。写代码是写作的一个派生类，精神的传递是写作的目的之一，所以写代码同样也有这个目的，让别人看到你的代码能被惊艳到。能决定你能走多远的下限靠两样东西，基础和hardwork。当对自己设定了较高的标准，hardwork是一件为了达到标准而自然而然发生的事情，随之而来的是慢慢拥有owner意识，之后就会主动去思考目前系统的问题，然后提出问题并去推动。自己给自己找需求，自己就是产品经理，开发者，测试。当拥有一些owner意识以后，就会去把玩目前的系统，corner case、压力、异常、极限情况下的表现都会去尝试测一下，没准线上就会遇到类似的情况。对于一个系统，别人看来已经完美了，正常运行不会挂了，但真正对问题把控到位的人是不会这么想的，他会感觉整个系统都是潜在问题，担心晚上随时会挂掉，第二天迫不及待起床要优化。</p>

<p>8.随时应对变化</p>

<p>不太喜欢打标签，比如你是前端，他是后端，更喜欢的说法是，我是一名开发，目前正在做XXX相关的事情。话里的意思是，随时准备好公司/环境/时代的改变，做技术转型，不要抱着自己已有的东西死死不放，那会是优势也是枷锁，同时也要意识到有些东西是沉没成本，一个理性人在考虑未来决策的时候不应该过多地考虑沉没成本。另外我认为现在是一个最适合学机器学习的时间，它不会像之前的安卓ios大数据那样成为一时的议论焦点，然后慢慢热潮退去，对于这一点我的行动是从两年前开始正经地系统学习，不算早但也不算太晚，就算以后不做这一行也要了解未来的趋势。现在最缺的不是研究人员，去看看每年顶会的投稿量就知道了，太夸张了，而是能把技术落地的人。</p>

<p>9.8/2法则</p>

<p>花20%的时间去了解一个领域80%，而不是花全部的时间去了解一个领域。你在一个领域花的时间越多，你的边际收益会越小，当边际成本大于边际收益的时候，如果没有特殊的理由，就该换一个领域去深入了，不同领域的思维碰撞没准也会产生更有价值的想法。</p>

<p>10.保持谦虚，保持开放的心态</p>

<p>从大了看，人类只是宇宙中的蝼蚁，而从长远看，人类的历史相对宇宙而言只是昙花一现，更何况我们每个人只是生活在自己有限的圈子里，没有理由去骄傲自大，有太多未知的东西了，自己引以为傲的东西可能就是别人的习以为常。我们唯一能做得，就是找到厉害的人，向他们学习，了解他们的想法，思考过后形成融合，让自己的想法和思路更加开阔，结果就是你会变得更厉害，然后会认识更多更厉害的人，形成良性循环。能看到和他人的差距然后去提升自己最后看到自己身上的成长，这件事本身就让人激动。</p>

<p>最后一点，也是最重要的：</p>

<p>11.自信自律，早早进行各方面的积累，形成马太效应</p>

<p>自信是，一件事还没有做呢，就知道自己可以做成。这和谦虚并不矛盾，谦虚的本质是保持开放和学习的心态。这里有个问题，怎么培养自己长期持续的自信？有一个小方法，建立一本自己的成功笔记本，把自己做成功的事记在里面，多小的事都可以，每当受挫失落的时候都拿出来看一下，就会原地复活的。当自信慢慢培养起来后，就会慢慢出现一种解决问题的惯性思维，可以理解为强者思维。遇到一个问题，拥有强者思维的人不会找借口，会去找要解决问题所缺少的东西，比如他会想，只要搞定了xx、yy和zz，那么这件事就搞定了。</p>

<p>未来的路还很长，认准的事不要过早放弃，2018希望各位朋友都顺利，生活开心。</p>

<p>（同时发布于<a href="https://zhuanlan.zhihu.com/p/33787285">知乎</a>）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何生成[0, N)中的随机数]]></title>
    <link href="http://zyearn.github.io/blog/2017/01/07/how-to-generate-uniform-distribution/"/>
    <updated>2017-01-07T17:40:00+01:00</updated>
    <id>http://zyearn.github.io/blog/2017/01/07/how-to-generate-uniform-distribution</id>
    <content type="html"><![CDATA[<p>写程序的时候，经常会遇到这样的需求：已知rand函数，生成一个范围在[0, N)的随机数。
比如我们有15个球，随机选择一个，则此时N等于15。
在这个问题中，我们通常希望这个随机数是满足均匀分布（uniform distribution）的，即每个数字出现的概率是一样的。
还有一类随机数生成问题，是要求实现rand这个函数本身的，<a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">这类问题</a>已经被广泛过，这篇文章不会讨论这类的问题。</p>

<p>之前看到的几乎所有的地方(包括我自己)都是这么写的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int r = rand() % N;</span></code></pre></td></tr></table></div></figure>


<p>后来校招面试百度的时候，一位叫戈君的面试官无意中告诉我这么写是错的，我回来想了一想，果然是不对的。
各位读者如果以前一直都是这么写的，不妨先不要继续看下去，自己思考一下错在什么地方。</p>

<p>为了说明错在哪里，我们举一个简单的例子：
我们假设rand()的返回的最大值是9，N等于7，那么rand()返回[0,6]时，直接返回该值；如果返回[7,9]时，则返回[0,2]，我们可以看出，返回0的概率是2/10，因为rand()得到0和7都会使结果为0，同理1和2的概率也是2/10，但是[3,6]中的数概率为1/10。这显然不符合均匀分布的定义。</p>

<p>稍稍想想可以发现：问题出在了N不能整除rand()返回的范围，使得最后“少了一段”。
试想上述情况中N=5，就不会发生这种情况，每一个值出现的概率都是2/10。</p>

<p>为了解决这个问题，思路是这样的：假设rand()的返回值范围是[0, M)，我们需要在这个范围划分出N个bucket，然后随机一个数，看这个数落到哪个bucket里，那么就返回这个bucket的标号。每份的bucket的长度L为M/N，那么这个范围中最后还剩余M%N。
如果rand() &lt; M - M%N，那么就返回该值/ L；否则就重试一遍，直到达到上述条件。</p>

<p>用C++写出来代码是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef unsigned long long ull
</span><span class='line'>ull bucket_size = M/N;
</span><span class='line'>ull remain = M%N;
</span><span class='line'>ull r;
</span><span class='line'>
</span><span class='line'>do {
</span><span class='line'>    r = rand();
</span><span class='line'>} while (r &gt;= M - remain);
</span><span class='line'>
</span><span class='line'>return r/bucket_size;</span></code></pre></td></tr></table></div></figure>


<p>这样返回值就是满足在[0,N-1]上的均匀分布。</p>

<p>另外，想到了一道面试题：函数rand5可以返回在[1,5]上的一个随机数，满足均匀分布，如何用这个rand5来实现一个rand7（即可以返回[1,7]上的一个随机数）？这个题的本质和上述思想是一致的，读者诸君不妨想想如何求解。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[无锁是万能药吗]]></title>
    <link href="http://zyearn.github.io/blog/2016/12/20/lock-vs-lockfree/"/>
    <updated>2016-12-20T21:17:00+01:00</updated>
    <id>http://zyearn.github.io/blog/2016/12/20/lock-vs-lockfree</id>
    <content type="html"><![CDATA[<p>经常会听到有人这样说，把某个地方的锁换成了无锁（lockfree）以后，性能提高了多少多少倍。
不禁会让人产生疑问：是不是只要有锁的地方，换成lockfree后都可以提高性能呢？</p>

<p>答案是具体情况需具体分析。</p>

<p>一部分朋友觉得用锁会影响性能，其实锁指令本身很简单，影响性能的是锁争用（Lock Contention<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>），导致scalability非常差<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。什么叫锁争用，就是两个线程都想进入临界区，但只能有一个线程能进去，这样就影响了并发度。有兴趣的朋友可以去看看glibc中pthread_mutex_lock的源码实现，在没有contention的时候，就是一条CAS指令，内核都没有陷入；在contention发生的时候，选择陷入内核然后睡觉，等待某个线程unlock后唤醒（详见<a href="https://en.wikipedia.org/wiki/Futex">Futex</a>）。</p>

<p>“只有一个线程在临界区”这件事对lockfree也是成立的，只不过所有线程都可以进临界区，最后只有一个线程可以make progress，其它线程再做一遍。</p>

<p>所以contention在有锁和无锁编程中都是存在的，那为什么无锁有些时候会比有锁更快？他们的不同体现在拿不到锁的态度：有锁的情况就是睡觉，无锁的情况就不断spin。睡觉这个动作会陷入内核，发生context switch，这个是有开销的，但是这个开销能有多大<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>呢，当你的临界区很小的时候，这个开销的比重就非常大。这也是为什么临界区很小的时候，换成lockfree性能通常会提高很多的原因。</p>

<p>再来看lockfree的spin<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>，一般都遵循一个固定的格式：先把一个不变的值X存到某个局部变量A里，然后做一些计算，计算/生成一个新的对象，然后做一个CAS操作，判断A和X还是不是相等的，如果是，那么这次CAS就算成功了，否则再来一遍。如果上面这个loop里面“计算/生成一个新的对象”非常耗时并且contention很严重，那么lockfree性能有时会比mutex差。另外lockfree不断地spin引起的CPU同步cacheline的开销也比mutex版本的大。</p>

<p>lockfree的意义不在于绝对的高性能，它比mutex的优点是使用lockfree可以避免死锁/活锁，优先级翻转等问题。但是因为ABA problem、memory order<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>等问题，使得lockfree比mutex难实现得多。</p>

<p>除非性能瓶颈已经确定，否则还是乖乖用mutex+condvar，等到以后出bug了就知道mutex的好了。如果一定要换lockfree，请一定要先profile，profile，profile！确保时间花在刀刃上。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>http://preshing.com/20111118/locks-arent-slow-lock-contention-is/<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>A classic paper on how different locking alternatives do and don’t scale: “The Performance of Spin Lock Alternatives for Shared-Memory Multiprocessors”<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>context switch的开销不仅仅是push和pop寄存器，它还引发了cache、TLB、branch predictor等CPU状态的丢失，具体如何测量CS的值，请参考“lmbench: Portable tools for performance analysis”<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>有同学问无锁和自旋锁有什么区别，不都是在一个循环里spin吗？自旋锁的本质还是应用层的锁，当一个线程持有锁后，被调度出去了，其它线程还是无法继续，而lockfree不是这样的，它可以保证至少一个线程make progress<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
<li id="fn:5">
<p>关于memory order，这是个不错的入门资料：http://www.chongh.wiki/categories/High-performance/<a href="#fnref:5" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回高中母校的演讲]]></title>
    <link href="http://zyearn.github.io/blog/2016/04/30/speech-in-my-high-school/"/>
    <updated>2016-04-30T18:38:00+02:00</updated>
    <id>http://zyearn.github.io/blog/2016/04/30/speech-in-my-high-school</id>
    <content type="html"><![CDATA[<p><img src="http://7d9pi3.com2.z0.glb.clouddn.com/DSC01674-min.JPG" /></p>

<p>今年三月底，我被邀请回高中母校嘉二中给高一的学生做了一个20分钟的讲座，名字叫《如果我回到高一，我会做&hellip;&hellip;》。听母校的老师说，现在的高一学生，也就是00后，个性太张扬，有非常强的自主意识，希望有一个还是学生的学长能够给他们一点启发。个性张扬从我的角度来看是一件非常好的事情，正是因为他们还这么年轻，才会初生牛犊不怕虎。等经历了更多，犯了一些错，踩一些坑，自然就会成长或者收敛一些。所以我倒没有老师那样的担心，毕竟每一代人都有各自老师眼中的大问题，但每一代都成长得非常好。</p>

<p>所以在我选题方面也是很纠结的，毕竟讲得太心灵鸡汤了怕对他们压根没用，讲得太偏实际操作了怕他们这个年龄也不懂，考虑到高一学生专注集中度，我只讲了三点，三点我认为对他们可能会有帮助的地方。精简了文字后，以下是我的演讲主体内容：</p>

<h2>主体内容</h2>

<p>学弟学妹你们好。</p>

<p>先自我介绍一下，我是二中2007届的学生，在二中度过了非常快乐的三年，在10年的时候通过自主招生进入了上海交大，我大一入学学的专业是船舶，后来因为兴趣的原因转专业到了计算机，大四的时候直接本系保研，所以我现在是一名研二的学生，会在明年毕业。</p>

<p>// 不讲人生经验，因为很多事情没有经历过就很难理解。比如说，我相信在座的大多数同学都有一个逼你们穿秋裤的妈，很不情愿，嫌妈妈很烦，10年后等你们做父母了，就会体会到父母的良苦用心。今天说一些你们能做到的事情。</p>

<h3>像学主课一样学副课</h3>

<ul>
<li>我高一高二的时候同学之间包括我有一个的现象就是重主课轻副课。当然以高考为第一原则的话这也无可厚非，我进入大学以后渐渐发现，这样的学习方式是不利于我个人的发展的，理想的方式应该是均衡地对待每一门课。</li>
<li>高中的九门课构成了一个人最基本的知识结构，缺一不可。并且每门课都是有联系的，你看物理依赖数学（可能高中体现得不多，等大学学大物的时候会发现好多都在算微积分），语文和历史相互依赖，语文的课文告诉你发生了什么，历史告诉你为什么会发生。只要你理解了这些课的关系，是非常有意思的。</li>
<li>我从实用的角度来看为什么副课是非常重要的。副课会慢慢地变成你生活的主课。拿历史课举个例子，历史课通过分析历史人物、历史事件，设身处地地想一想当事人的感受，来教会你思辨的能力，这个能力对你们往后的人生非常重要，帮助你思考、做决定的时候更加明智和理性。</li>
<li>其次，副课会拓宽你的知识面，知识面影响一个人思考问题方式。知识面广的人思考问题更加全部。比如说地理课，极大地拓宽对宏观世界的认识。我非常庆幸自己高中学好了地理，因为它解释了非常多的我小时候的问题，比如为什么会有春夏秋冬？为什么北半球的季节和南半球相反啊？为什么在夏天和冬天的白天是不一样长的啊？这些问题在这门课中得到了完美的解答，对我而言学这门课非常非常值。</li>
</ul>


<h3>去尝试</h3>

<ul>
<li>在我18岁的时候，我认识了一个年纪比较大的学长，他经常说年轻真好，我不理解啊，我羡慕他事业有成，人生美满，而我什么都没有啊，后来我发现18岁的我拥有世界上最贵的东西，时间。</li>
<li>现在的你们刚好也拥有时间。时间多意味着可以随便尝试，即使做失败了也没有人会来责备你，这个过程叫试错。试错能够让你尽早发现哪些是你的兴趣，这个兴趣不一定会成为你们的工作，兴趣能够让你在一个人的时候还能自得其乐。</li>
<li>有自己的兴趣的一个最大好处是高考报考专业非常简单。我在高三的时候不知道我未来要干什么，于是填了全国第一的船舶。但没兴趣，同时对计算机感兴趣，然后马上转专业，虽然走了点弯路，但结局还算完美。建议：如果实在不知道选什么，就选计算机。为什么？我给你们一个客观的理由：现在是一个互联网高速发展的时代，计算机人才处在一个非常缺乏的状态，并且可以满世界挑工作。 - 刚刚说了高考的话题，我们回来，继续看尝试这个话题。曾经有人做了一个研究，想调查现在7、80岁的老人中人生中最后悔的事是什么。调查结果显示每个人都不一样，有人后悔没去环球旅行、有人后悔没有多花时间陪孩子。但有一点是相同的，绝大多数人后悔“没做”某事。</li>
<li>这个研究给我们的启发是，面临机会，千万不要再说“算了，我不行，下次再说”，而是抓住这个机会。</li>
</ul>


<h3>写日记</h3>

<ul>
<li>从大一开始每天写日记，我非常后悔没能在高一就开始写。日记的好处是让你清晰地知道自己思想是如何成长起来的，如果你读去年的东西写的东西特别幼稚，那就对了。</li>
<li>一开始写每天干了什么，后来回去读发现没有任何意义。开始写每天的一些思考，后来慢慢上升到了哲学层面的问题。比如什么是重要的东西？如果我获得用不完的钱，还要不要工作。这些东西回头看看会非常有意思。</li>
<li>曾子曰：“吾日三省吾身”，我们没有必要省那么多次，一次足矣，在睡觉前花5~10分钟，把所思所想记下来，可以用软件来记，绝对是你未来的财富。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[抽象与计算机课程]]></title>
    <link href="http://zyearn.github.io/blog/2016/03/06/cs-courses-and-abstraction/"/>
    <updated>2016-03-06T21:43:00+01:00</updated>
    <id>http://zyearn.github.io/blog/2016/03/06/cs-courses-and-abstraction</id>
    <content type="html"><![CDATA[<p>如果要问计算机领域中哪个思想对我的帮助最大，那么应该就是抽象（abstraction）了。本文主要介绍一下抽象以及它和计算机课程的关系。</p>

<p>第一次接触抽象是我大学低年级学数据结构的时候，记得很清楚当时学一个概念叫抽象数据类型（abstract data type），大概意思就是一个数据结构，接口是一回事，实现是另一回事，比如栈，作为使用者你只需要知道它有push、pop、isEmpty等方法，但它的底层实现到底是array还是linked list，你是不需要知道的。</p>

<!--more-->


<p>用通俗一点的话说，抽象就是你好好做自己的事，以及知道别人能帮你干什么事，至于别人是如何帮你完成的，你没必要知道。</p>

<p>这个简单的思想大大提高了开发者的效率，让开发者只专注于要解决的问题，而不是一些细枝末节的事。</p>

<p>孟岩在它的<a href="http://blog.csdn.net/myan/article/details/5877305">博客</a>里也提到过“关注重点”这件事，虽然没有明显地提及抽象二字，但他的意思和抽象表达的意思是一样的：</p>

<blockquote><p>我主张，在具备基础之后，学习任何新东西，都要抓住主线，突出重点。对于关键理论的学习，要集中精力，速战速决。而旁枝末节和非本质性的知识内容，完全可以留给实践去零敲碎打。</p>

<p>原因是这样的，任何一个高级的知识内容，其中都只有一小部分是有思想创新、有重大影响的，而其它很多东西都是琐碎的、非本质的。因此，集中学习时必须把握住真正重要那部分，把其它东西留给实践。对于重点知识，只有集中学习其理论，才能确保体系性、连贯性、正确性，而对于那些旁枝末节，只有边干边学能够让你了解它们的真实价值是大是小，才能让你留下更生动的印象。如果你把精力用错了地方，比如用集中大块的时间来学习那些本来只需要查查手册就可以明白的小技巧，而对于真正重要的、思想性东西放在平时零敲碎打，那么肯定是事倍功半，甚至适得其反。</p></blockquote>

<p>最近发现，计算机专业的课程完全可以用抽象来解释：每一门课想做的事就是利用下层提供的接口，实现功能，然后再给上层提供接口。这样一层一层的抽象就构成了所有的专业课。</p>

<p>举一个例子来说明这个从上往下的层级抽象是如何组织的。</p>

<p>先来看最高层，问题。刚学编程的时候，会先学一门课导论课或者编程入门课，我当时的入门课叫做“程序设计”，课程内容是介绍一些问题，然后介绍一点编程语言的知识，作业是一些编程问题，比如八皇后、素性测试之类的比较常规的编程题。这门课的目的一般都是介绍“问题”的，介绍计算机科学有哪些有挑战的问题，让学生对计算机专业有一个感性的认识，而不是对特定编程语言或者算法的学习，所以这类课程一般用python来编程。</p>

<p>再往下一层，算法和数据结构。这一层的目的是学习/实现各种算法/数据结构，提供给上层功能。比如排序，问题解决者只要知道这里应该用快速排序，而不是选择排序，而把快速排序的实现留给这一层的开发者，从而使各种优化都可以对上层透明，比如小数组变插入排序、中位数取pivot、三向快速排序等，这些优化调用者完全不必要知道，他只需要知道：哇，这个库提供的快速排序还真快。</p>

<p>再往下一层，语言层，毕竟所有算法都要由某一门语言来实现。这一层的存在使得算法的设计可以脱离具体的语言。不同语言又提供了不同的抽象，像函数式语言就比命令式语言的抽象级高，更高的抽象级意味着更加专注问题本身（不需要考虑内存布局、CPU使用等）以及更少的代码量。</p>

<p>再往下一层，编译器/解释器。我们编写代码是用高级语言，而cpu上执行的是机器码，所以这个抽象层帮我们做了这个转化。这个抽象层的好处是，高级代码的编写者完全不需要知道这个程序所运行的操作系统和硬件平台，任何有该语言编译器/解释器的机器，程序都可以跑（从而实现了跨平台）。应用层开发者可以不用知道这个由高级语言到机器码的转化具体是怎么实现的，毕竟编译器优化的编写和优化完全是一个团队的工作量，开发者关注问题的解决，编译器负责转化出高效的机器码，各干各的，这正是抽象的重点。</p>

<p>再往下一层，操作系统。OS向开发者抽象了硬件（CPU、内存、Disk、NIC等），并且以syscall的形式向用户提供服务。OS的设计是最能体现抽象的，虚拟内存和进程让程序以为自己独占着内存和CPU，同时隔离了不同进程以防恶意进程；文件系统让用户可以方便地读取存储数据，而不需要直接操作底层的硬盘；文件描述符抽象了底层的设备（pipe/file/device/socket/&hellip;）。</p>

<p>再往下一层，ISA（Instruction set architecture），俗称软件与硬件的接口。这个俗称是非常形象的。指令集架构，说得简单点就是机器码，也可以理解为一个协议。ISA标准制定者指定一套指令集（比如x86、PowerPC、SPARC），然后编译器开发者需要根据这个标准/协议来编写对应的编译器；CPU制造商需要根据这个标准/协议来制造出支持这套ISA的CPU（比如intel的CPU支持x86/x86_64）。也就是说，软件/硬件都依照这个ISA来设计，那么就可以对接了。</p>

<p>再往下一层，组成原理和体系结构。这一层要做的事情是借助数字电路给它提供的功能（组合电路和锁存器），来设计一个能实现某种ISA的CPU，让编译器生成的指令可以在此CPU上运行。大学里一般会开一门叫“计算机组成原理”的课，一开始学单周期CPU的实现（取指、译码、执行&hellip;&hellip;），为了提高效率又提出了流水线的实现。为了发掘更高的效率，之后又会学一门叫“计算机体系结构”的课，这门课的目的是为了发掘更高的并行，从而制造出更快的CPU。那这一层是如何用数字电路提供的功能？举两个典型例子：一、CPU为了做计算会有ALU模块，而ALU模块正是一个组合电路（输入确定那么输出确定）；二、在流水线寄存器中每一个时钟上升沿都会保存输入的值，在这个时钟周期内组合电路会根据这个新值计算出结果传输到下一级流水线寄存器的输入，等待下一个时钟上升沿的到来，这里的流水线寄存器正是某种锁存器的实现，而CPU开发者并不需要这个数字电路模块是怎么实现。</p>

<p>再往下一层，数字电路。这门课的目的是教学生如何利用基本的门电路（与非或门）来实现一些高级的功能（译码器、多路复用器、锁存器、时序电路&hellip;&hellip;），然后给上层提供功能。上数字电路课是一个用砖搭房子的过程，由基本的门电路开始，慢慢构造出复杂的电路。数字电路不需要关心基本的门电路是如何实现的，因为这正是模拟电路向上层提供的功能。</p>

<p>再往下一层，模拟电路。这一层实现了与或非等基本门电路。比如非门、与非门、或非门都可以通过若干个p/n型MOS晶体管构成，而与门可以通过连接一个与非门和非门构成，或门可以通过连接一个或非门和非门构成。很多同学都觉得模电对于计算机的同学不必要学，而我认为相反，它是你构建整个计算机抽象层级的基石。</p>

<p>再往下一层，就不是计算机领域研究的事了。</p>

<p>当然，还有很多专业课我并没有提及，比如网络，它是OS提供的功能，以文件描述符的形式提供给用户使用；在网络协议栈实现的细节里，又分了好几层抽象，这就是我们熟知的OSI七层网络模型（有时候被抽象为五层：Application、Transport、Network、DataLink、Physical）。各位可以自己回忆一下大学里上过哪些专业课，以及它应该放在抽象的哪一层上。</p>

<p>仔细一想会发现，几乎所有的技术书籍都尝试在解决某一层上的问题，利用下层提供的抽象，然后向上层提供功能。</p>

<p>让我们脱离计算机领域，再往高一点看，会发现整个计算机领域就是在为别的领域提供功能、并隐藏了细节：医疗、交通、餐饮、支付&hellip;&hellip;</p>

<p>抽象，让生活变得更简单了一点。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推荐一门课：6.828]]></title>
    <link href="http://zyearn.github.io/blog/2016/02/24/recommmend-6-dot-828/"/>
    <updated>2016-02-24T20:19:00+01:00</updated>
    <id>http://zyearn.github.io/blog/2016/02/24/recommmend-6-dot-828</id>
    <content type="html"><![CDATA[<p>这篇博文的目的是向大家推荐一门课：MIT的<a href="https://pdos.csail.mit.edu/6.828/2014/index.html">6.828</a>。</p>

<p>这门课主要讲的是操作系统原理与实践，具体分三个部分：lectures，labs and readings。
Lectures部分会通过介绍xv6来阐述OS原理，并解读xv6源码；
Labs是这门课的实践部分，课程会提供一个OS的框架，但核心部分全部都是缺失的，需要学生来填写核心代码来实现这个OS；
Readings部分会阅读一些paper来了解一些更深入、更有意思的topic。</p>

<!-- more -->


<p>一个很自然的问题是，它与别的OS课程的区别在哪里？
最大的一个区别是，这门课的实践部分比重非常非常大，而OS本身就是一个实践学科，所以6.828的编程练习会让你对OS的概念非常清楚。
具体来说，这门课一共有7个lab，写完这7个lab，一个操作系统就被写出来了（名字叫JOS，是专门为这门课设计的Exokernel，麻雀虽小五脏俱全），除此之外，老师们为了让学生了解不同OS的架构和风格，在讲课阶段会主要以xv6（一个教学的操作系统，它是Monolithic kernel）的代码讲解OS概念，也就是说，在学期末，你会自己编写一个Exokernel和完整阅读一个Monolithic kernel的代码。</p>

<p>虽然我本科阶段也上过OS，但大作业的量完全没有到达这个编码强度（当时交大的OS课大作业是编写一个toy文件系统），导致自己以前对很多OS的概念和实现细节都是只见树木不见森林。然后从去年12月初，一共用了三个月的时间把这门课刷完了，对OS的理解清楚了很多，以及本科学的很多知识点都串了起来。</p>

<p>基于这个原因，不管你是学生还是已经工作几年的前辈，如果你想了解一个小型OS具体到代码是如何实现的，这门课是首选。</p>

<p>介绍一下每个Lab的需要做的事情：</p>

<ul>
<li><p>Lab1是熟悉的过程，需要学习QEMU模拟器的使用、开机启动流程、调试工具、bootloader、以及整个加载kernel的流程。做完这个lab会具备基本的内核调试能力，以及掌握开机到通电，bootloader是如何加载kernel的。</p></li>
<li><p>Lab2要完成JOS的的内存管理模块，需要学习一些计算机基础知识，如虚拟地址系统是如何工作的，地址空间是如何切分的，物理页面是如何管理的。做完这个lab将会给JOS添加最基本的内存管理功能，即Kernel其余模块需要物理页，这个模块可以分配出来。</p></li>
<li><p>Lab3为JOS添加进程的支持、异常/中断的支持、系统调用和页中断的支持。这个lab内容比较多，但收获也比较大，做完后会对从用户态陷入内核态，执行系统调用，然后返回这整个流程都非常清楚（不是泛泛的清楚，而是代码级别的清楚，这是和学概念不同的地方）。</p></li>
<li><p>Lab4为JOS添加多核支持、RR调度、COW的fork、抢占式内核、时钟中断和最基本的IPC机制。做完Lab3和Lab4，一个能用的OS已经出来了，但用途非常有限，因为没有文件系统和网络的支持，Lab5和Lab6就会做这两件事情。</p></li>
<li><p>Lab5为JOS添加基于Disk的文件系统、块缓存、实现键盘中断、修改一个shell支持最基本的功能。完成这个Lab后就可以在shell里面输入命令以及文件系统的支持了。JOS没有实现crash recovery，在xv6用log的方式实现了crash recovery，代码都非常好（虽然效率很差&hellip;课里会讲）。</p></li>
<li><p>Lab6为JOS添加网络的支持。网络部分主要分两个大块，一个是协议栈的编写，一个是驱动的编写。协议栈太复杂了，于是课程提供了现有的lwip库。我们需要实现驱动，这涉及到阅读intel的网卡硬件手册，这是本课程让人头痛的地方之一。完成驱动以后，需要完成用户态的network server（网络服务以用户进程的形式提供是Exokernel的特点之一，和Microkernel很像），还需要完成一个用户态的web server，完成之后经过QEMU的端口转发，在host机器可以访问qemu里面运行虚拟机的web server！第一次运行成功也是觉得非常神奇，因为OS从上到下，在此时此刻，全部打通了，可以向外提供服务了，并且这个OS的核心代码全部是在课程里完成的。</p></li>
<li><p>Lab7和Lab6只需要选择一个做，Lab7是一个需要组队的开放式课题。</p></li>
</ul>


<p>不可否认的是有些lab真的非常让人头痛、一个bug可能会调很久甚至几天没有进展，但到最后收获的远多于付出。</p>

<p>如果你对上面的Lab有兴趣，那花三个月去上一下这门课会非常值。其实可能用不上三个月，我是跟着课程进度一点点做的，如果有一点OS基础可以直接做Lab，稍微加班加点一个月左右也可以完成了。</p>

<p>JOS还有很大的提升空间，归根结底这只一个“working”OS，离工业级使用还差很多，以下是我总结的一些改进点：</p>

<ol>
<li><p>JOS和xv6的内存管理方式都是空闲链表，这导致如果内核想要连续的物理内存，将十分困难（因为碎片的存在，即使没有碎片，也将是O(n)的复杂度），所以linux采用了buddy system来解决碎片问题。（至于内核为什么需要连续的物理内存，请看我在V2EX上问网友的一个<a href="http://v2ex.com/t/256450">问题</a>）</p></li>
<li><p>JOS和xv6的进程调度是最简单的RR方式，这使得它们无法应用在某些特殊的场景下，而且父进程很容易fork子进程把CPU时间全抢了。</p></li>
<li><p>JOS和xv6根本就没有磁盘调度算法，应用层来一个读写磁盘请求就直接由驱动发送给磁盘控制器。</p></li>
<li><p>JOS的文件系统效率差，且不支持crash recovery，即使是实现了crash recovery的xv6，效率也非常差。不过在文件系统设计中，performance（don&rsquo;t write the disk）和safety（write the disk ASAP）本身就是一个tradeoff。</p></li>
<li><p>&hellip;</p></li>
</ol>


<p>上完这门课后推荐看一下Rober Love的《Linux内核设计与实现》，会发现JOS到底哪里做得不好以及Linux是如何解决的。</p>

<p>附：Lab的<a href="https://github.com/zyearn/6.828-labs">代码地址</a>和上这门课时的一些<a href="https://github.com/zyearn/6.828-labs/blob/lab6/LabNotes">笔记</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[参加饿了么编程马拉松感]]></title>
    <link href="http://zyearn.github.io/blog/2015/12/02/eleme-hackathon/"/>
    <updated>2015-12-02T14:30:00+01:00</updated>
    <id>http://zyearn.github.io/blog/2015/12/02/eleme-hackathon</id>
    <content type="html"><![CDATA[<p>饿了么在今年十一月的时候举办了一个黑客马拉松，官方主页在<a href="http://hackathon.ele.me/">这里</a>，看了简介以后我认为有两点比较吸引人。</p>

<p>首先，比赛形式比较新颖，之前也参加过类似的马拉松以及听闻过很多XX编程马拉松，形式都是差不多的：接受组队报名，然后花上两天时间大家待在一个地方通宵编程实现一个和主办方做的事完全没有关系的创意，一般会在第二天下午开始做presentation，最后会根据评委打分决出获胜队伍。这种类型的比赛，根据我的观察，presentation是最重要的，其次是idea，最后才是技术。<!-- more -->而这次的饿了么举办的马拉松分初赛和决赛，初赛前10名进入决赛，初赛需要实现一个功能，最后评测完全靠的是实力和技术，分数公开透明。虽然还不知道决赛题目是什么，但也令人期待。</p>

<p>其次，如果真的进了前10名，能去参加决赛，大家可能都是非常强的高手，想想也令人激动不是么。</p>

<p>于是和另外两位小伙伴一起参加了这次初赛。</p>

<h2>题目描述</h2>

<p>初赛的题目是使用Python, Java, Go三种语言（任选其一）实现一个“限时抢购”功能。具体来说，就是实现一个web服务，对外提供一个restful接口，让模拟用户可以通过接口来抢购数据库中的食物。评分使用功能测试、性能测试的结果做为指标。功能测试就是看有没有超售，错误处理之类的，通过了功能测试才能进入性能测试这个打分的环节。</p>

<h3>性能测试</h3>

<ol>
<li>给定 100 个食物，每个库存 1000</li>
<li>脚本模拟 1000 个并发用户同时进行抢单。（登录 -> 查看食物列表 -> 随机选择 1-3 个食物购买 -> 下单）</li>
<li>将按照“成功下单数/秒”的峰值进行排名</li>
</ol>


<h3>测试环境</h3>

<ol>
<li>2CPU-4GB 服务器 * 3，运行应用。（请求会随机分布到 3 台服务器上）</li>
<li>2CPU-4GB 服务器 * 1，提供 redis</li>
<li>25GB 1000qps 腾讯云数据库，提供 mysql</li>
<li>12CPU-12GB 服务器 * 1，运行性能测试脚本</li>
</ol>


<p>一个能跑的程序还是很容易实现的。其中有一个难点是，因为是分布式服务，所以我们必须保证下单并减库存的操作是原子的，传统的读-改-写在高并发情况下不适用，好在redis支持lua脚本是原子的，于是这个问题就解决了。</p>

<h2>数据库设计</h2>

<p>因为提供了redis，又是性能的比赛，所以我们决定放弃mysql，完全用redis来做。</p>

<p>因为负载均衡的存在用户请求可能被分发到任何一台应用服务器上，redis中需要存储一些共享的数据，如用户登录后的token，用户的购物车，用户的订单，以及最重要的食物库存，如下图所示：</p>

<pre><code>KEY                             VALUE
---------------------------------------------------------
token:user                      hashmap: {&lt;tokenid&gt;: &lt;userid&gt;}  // 检测token的合法性
user:order                      hashmap: {&lt;userid&gt;: &lt;orderid&gt;}  // 获取某个user的订单，系统只允许一个用户下一单，所以这个hashmap能检测是否重复下单
cart:user                       hashmap: {&lt;cartid&gt;: &lt;userid&gt;}   // 获取购物车是哪个user的
cart:&lt;cartid&gt;                   hashmap: {&lt;foodid&gt;: &lt;cnt&gt; }     // 该购物车的食物及数量
order:user                      hashmap: {&lt;orderid&gt;: &lt;userid&gt;}  // 这个order对应哪个user
order:&lt;orderid&gt;                 hashmap: {&lt;foodid&gt;: &lt;cnt&gt; }     // 每一个订单包含的食物及数量
food:stock                      hashmap: {&lt;foodid&gt;: &lt;stock&gt;}    // 食物的库存
</code></pre>

<h2>框架的选择</h2>

<p>一开始我们用python写了个能跑过测试的版本，能异步的地方都用了协程，但是分数还是比前十的队伍差了很多，于是我们怀疑是不是语言层面的问题导致了分数差那么多，于是我们队伍的小伙伴对python和go做了一个性能比较，其中每一次访问<code>/</code>都会使redis调用一个脚本，这个脚本和我们下单的操作运算量差不多，结果如下：</p>

<pre><code>LANG    WEB         REDIS             METHOD      TIME
---------------------------------------------------------
python  tornado     redis-py          coroutine   1.406ms
python  tornado     redis-py          sync        1.022ms
python  aiohttp     asyncio-redis     coroutine   0.879ms
python  falcon      redis-py          gunicorn    0.669ms
node    express.js  node-redis        event       0.301ms
golang  net/http    gopkg.in/redis.v3 coroutine   0.245ms
</code></pre>

<p>我们发现在相同的环境下，go的性能是最好，虽然很不情愿，但不得不放弃python用go重写。事实证明，用go以后分数有明显上升。</p>

<h2>实现</h2>

<p>食物的库存存在redis的hashmap中(foodid映射到stock)，下单用lua脚本来做，查询库存就返回所有食物列表和相应库存。后来我们发现这个方法效率太低，每次查询库存都要返回所有的食物，即使很多食物库存都没有变化过，太浪费I/O。于是我们小伙伴提出了一个基于timestamp的方法，结果就是每次查询库存值传输某个时间之后变化的食物，大大减少了流量。</p>

<p>具体方法是这样做的：本地存储一个当前timestamp，并且redis端存储一个foodid到该食物最后更新时间，然后把(更新时间|foodid|foodstock)这个长整型存储在redis中的ordered set里，key就是更新时间，于是我们在查询库存的时候，只需查询从app的timestamp到正无穷的时间里有哪些元素就可以了，复杂度是log(N)的，然后根据这些元素的值就可以还原出id和stock值。</p>

<p>这是个非常精妙的思想，当时在腾讯实习的时候看过微信内部的一篇文章，说微信为了同步不同设备上的消息记录，用的就是这个时间戳的思想，差分传输而非全部。</p>

<p>下单操作就麻烦一些了，先根据id找到这个食物的最后更新时间，然后根据这个值从ordered set里拿到(更新时间|foodid|foodstock)这个长整型，分解出id和stock，减完库存还得删除原来的元素插入新的元素，这些都是log(N)的操作。</p>

<h2>突破</h2>

<p>随着比赛的进行，我们发现自己的分数卡在一个瓶颈了。某一天晚上我突然发现，我们实现了系统的强一致性，而题目里根本没有要求我们这么做！我们用timestamp的目的是为了让查询库存节省流量，但是带来的tradeoff是每次下单的时候都有好几次log(N)操作（需要根据查询食物最后更新时间来找到这个食物的库存，而后者存在redis的ordered set里）。但是在测试的时候根本就没有测获得库存的强一致性，题目要求的是最终一致性，所以我们没必要实现地那么老实，只要一个goroutine隔个两秒去redis拉一下数据就可以了，然后我们的下单操作变得异常简单，把stock存成hashmap，只是几个简单的O(1)操作。</p>

<p>我们为了库存显示的强一致而牺牲了下单的效率，这明显是不值得的，我们宁愿下单快，但库存会有一些误差。这在实际工程也是合理的，网站显示库存还剩一个，但是你下单的时候发现库存为0，这是用户可以理解的，手慢了就被别人买掉了。但是这个妥协大大带来了下单峰值的上升。</p>

<h2>优化</h2>

<p>整个比赛后期就是在不断优化的过程中，其中一个比较难的地方在于如何确定瓶颈，在redis？在I/O？还是在APP服务器的处理速度？最后几天就是在不断地对程序做profile然后性能优化然后再做profile。一个印象比较深的例子是有一个操作我在不断纠结要不要放到redis的lua脚本去做，如果放了会增加redis的负载，但是会减少网络I/O的时间，线上测出来的结果又是差不多的，那这个做还是不做？在比如reids线程池到底搞多少个才是合适的？</p>

<p>另外，把能缓存的数据全部缓存起来，性能会提高不少。</p>

<h2>TradeOff</h2>

<p>做这个项目中遇到了太多需要tradeoff的地方：</p>

<ol>
<li>代码的可读性和性能，为了提高性能我们牺牲了很多可读性</li>
<li>不要用第三方库，虽然手写一些功能会比较累、易出错，但有些第三方库为了通用性，使得效率大大下降。我们把使用的一些第三方库都删掉以后，效率又提高了不少</li>
<li>下单一定要快，这样每秒的单数就增加了，而实时显示库存就显得不那么重要</li>
<li>用户注册返回的token如何生成得高效且具有随机性</li>
<li>将Go程序设置为多核后，对共享变量的读取用乐观锁还是悲观锁</li>
</ol>


<h2>代码</h2>

<p>放在了<a href="https://github.com/zyearn/eleme-hackathon">github</a>上。</p>

<p>我们的代码峰值是4600多单每秒，而饿了么大学（好像是内部员工组成的队伍）的实现是5000多单每秒，还是有400的差距。</p>

<h2>感想</h2>

<ul>
<li>队友很重要，两个小伙伴很给力（<a href="https://abcdabcd987.com/">乐群</a>和<a href="http://www.zhihu.com/people/lz1996">骆神</a>）</li>
<li>Go好简洁，很好用</li>
<li>做系统考虑好TradeOff很重要</li>
<li>redis好强大，单线程事件驱动网络I/O的典范</li>
<li>这是一个优化比赛，看谁能优化到极致</li>
</ul>


<h2>彩蛋</h2>

<p>在看了饿了么5000分的标准实现后，发现这400分的差距还是有原因的，为了性能redis里面存的越少越少，这样I/O次数就少，罗列一些我们组没有注意到的点：</p>

<ul>
<li><p>token其实是不需要存redis的，token如果是userinfo的一个函数映射，那么每台机器都可以根据这个函数事先为每个user生成一个token，而不是随机字符串。比如md5(userId)作为token，然后在起服务器的时候就把token生成好，并且维护一个token到userinfo的映射（为了之后带token的请求找到该user），就完全不需要redis了。这样做虽然好，但token好像无法过期了？于是我问了一下主办方，给我发了一篇<a href="http://lucumr.pocoo.org/2013/11/17/my-favorite-database/">文章</a>，思路非常好，把client当做database，这样本地就根本不用存一个用户相关的数据，比如token。虽然这篇文章表明了token可以不用存储，但没有回答token的生成和userinfo相关到底是不是一个好的选择？在我们的实现里，用了随机字符串来作为token，每次都是on-the-fly生成，效率明显会差一点</p></li>
<li><p>为了判断user是否只下了一单，在我们实现里用了user:order这个hashmap。官方没有这个数据结构，只维护了order存了哪些food和count（也是个hashmap），然后每个user的order被命名为<code>o_&lt;userId&gt;</code>，所以只要用<code>EXIST</code>命令看一下这个key存不存在就知道用户有没有重复下单了</p></li>
<li><p>把userId嵌到购物车Id里面，那么reids就不用存购物车Id到userId的映射了（值得吐槽的是判定购物车Id是不是有效的方法是传来的string是否满足他事先规定的pattern，这在现实中完全不能用啊）</p></li>
<li><p>我们的实现里下单时把购物车这个hashmap完整地复制到了订单这个hashmap，而官方只用了一条redis命令<code>RENAME</code></p></li>
<li><p>官方实现里，每个用户下单的orderId竟然是事先生成好的，其值就等于userId，难道这个不应该是on-the-fly生成的么，这样的好处是下单返回成功和上述的<code>RENAME</code>可以异步执行，这样的设计使得我们设计中的order:user成为累赘了，因为userId本身就是orderId，根本就不用这个查找</p></li>
<li><p>在官方实现里是怎么查询所有订单的呢？因为订单都是以<code>o_</code>开头的，所以用redis的命令<code>KEYS o_*</code>就可以获取所有以<code>o_</code>开头的key，那么所有订单也自然就拿到了，这里需要(1+n)次（1次查询所有订单名字+根据返回的名字查询n个订单的详细内容）redis访问，但查询订单不在benchmark里，所以实现得耗时一些没有影响</p></li>
<li><p>官方用了go-reuseport这个库，即多进程端口复用，据说比单进程端口要性能好一些</p></li>
<li><p>官方把go的GC关掉了，据说效果不大，在我们的profile结果里GC也只占了很小一部分</p></li>
</ul>


<p>结论就是，虽然官方实现有几点值得吐槽的地方（比如判定作弊的标准不太明确，导致可能有些选手即使想到了优化方法，然后觉得这个实际中不能用，就放弃了），为了性能牺牲掉了很多实用性（比如官方Go的实现没有可拓展性，假如来了一个需求说一个用户可以下多个订单，就要大改了），毕竟是个性能比赛。但确实有很多地方值得学习，根据这个特定的场景，redis数据库设计得非常简洁，大大减少了I/O次数（瓶颈），而且用了许多redis技巧和Go技巧，特别是发出异步redis请求的goroutine和channel的使用，对于初学Go的我帮助很大。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何用C/C++写一个基于事件的爬虫]]></title>
    <link href="http://zyearn.github.io/blog/2015/09/09/how-to-write-a-event-based-crawler-using-c/"/>
    <updated>2015-09-09T20:52:00+02:00</updated>
    <id>http://zyearn.github.io/blog/2015/09/09/how-to-write-a-event-based-crawler-using-c</id>
    <content type="html"><![CDATA[<p>在去年三月份的时候，写过一篇<a href="http://zyearn.github.io/blog/2014/03/08/zhihu-spider/">文章</a>，讲了一下如何写一个知乎爬虫，爬下最高票的答案，并且把代码放到了<a href="https://github.com/zyearn/zhihuCrawler">github</a>。在这一年多的时间里，前前后后有很多人来问我关于这个爬虫的一些实现细节，在回答他们的同时发现自己原来的代码真是写得太烂了，最近正好有空，把代码和架构都重写了一下，不能再误人子弟了。</p>

<!-- more -->


<p>所以有了这篇文章，记录下自己的一些改进，以及尽可能说清楚如何用C++实现一个高性能爬虫。</p>

<h2>为什么要用C++写</h2>

<p>在继续往下看之前一定要先想清楚一个问题，现在用Python或者NodeJS可以非常快速地开发出一个爬虫，库齐全，开发成本非常低，那为什么还要用C来写爬虫？答案是这要看你的目的。如果你单纯是为了完成一个数据抓取的任务，当然是任务完成得越快越好，以后代码越好修改越好，首选就是那些库齐全的动态语言，但如果你的目的是为了理解底层系统，理解抓取数据的每一个环节，那么我的推荐是用C++写吧，并且所有轮子都自己造。我的目的是后者，所以选择了用C来写。既然所有轮子都自己造了，那这篇文章应该叫，如何不用任何第三方库，只用C/C++内建函数来完成一个网络爬虫。</p>

<p>用Python写会是什么样子？有Requests库来封装HTTP请求，有BeautifulSoup来解析HTML，大大减少了开发难度，你只需要知道爬虫的一般流程，很容易写出一个能跑的代码，用NodeJS也是一样的。</p>

<h2>知乎爬虫原理</h2>

<p>如果有读者不太清楚爬虫的原理，请先看一下这篇<a href="http://www.zhihu.com/question/20899988">入门文章</a>。</p>

<p>接下来简单说一个我的zhihu爬虫的原理，因为我的目标是爬下最高赞/最高关注这些类型的答案和问题，所以从用户主页出发是最好不过的，比如从用户主页点击“回答”，就可以看到用户的所有回答，然后抓下来，点击“提问”，就可以看到用户所有的提问。把所有用户的所有回答/提问都抓下来然后根据点赞数/关注数排序，就是我想要的结果。那所有用户怎么得到？从一个用户出发（即队列中的初始URL），把TA的所有关注的人和关注者都爬下来，不重复地放入URL队列中，等到当前用户处理完，再从URL队列里拿下一个用户，如此循环即可。</p>

<p>仔细想想，这个方法会有一个问题，如果一个人即不关注别人也不被别人关注，且不在初始URL队列中，那么这个用户的回答和提问永远不会被抓到。更一般的结论是，如果有用户群构成“孤岛”，那么这些用户群都不会被爬虫访问。举个例子，A、B互相关注，C、D互相关注，如果我们将A放入初始URL队列，那么爬虫只可能抓下A、B的数据，因为C、D构成了“孤岛”，怎么解决这个问题？</p>

<p>再想想，这个问题真的有必要解决吗？这个问题会对我们造成困扰的情况是，一个大V答了一个赞数很高的问题，但是TA竟然在某座“孤岛”上，如果我们称大部分人所构成的连通图叫主图，那么这个大V构成的“孤岛”和主图上的人一点关系都没有，即不被关注也不关注别人，这几乎是不可能的事情，所以这个问题不需要解决。</p>

<h2>如何用C++写爬虫</h2>

<p>无论用Python或者C++写爬虫，底层都是一样的，都是和server建立若干个TCP连接，然后把HTTP请求写入这个TCP socket中，等待server的数据返回。为了高效处理I/O，在linux平台下需要用epoll（别的平台请用各自的机制）。</p>

<p>所以一个C++爬虫步骤大概是这样的，本质上就是一个事件循环（event loop）：</p>

<ol>
<li><p>初始化epoll，并和server建立TCP连接</p></li>
<li><p>从URL队列中拿出url，并准备好http请求</p></li>
<li><p>将http请求写入到这个TCP socket中，并把这个socket加入epoll中</p></li>
<li><p>检查活动事件（epoll_wait）</p></li>
<li><p>处理事件，读取HTML，解析HTML，处理HTML，然后把相关未处理过的URL放入URL队列中</p></li>
<li><p>回到第2步</p></li>
</ol>


<h2>原来的代码结构</h2>

<p>先简单描述一下去年写的爬虫代码是怎么误人子弟的。</p>

<p>程序从队列里拿到一个URL后，需要去下载这个URL的页面，解析出我需要的数据，然后把它的下一层URL加入队列中。原来的爬虫代码就老老实实地实现了这个步骤，阻塞地等待页面下载完成，再去处理这个页面。其实这是很低效的，因为阻塞的这段时期我们什么都干不了，浪费了带宽。为什么不把队列里的其它URL请求一起发出去呢，然后有数据来了我就处理。这就是为什么爬虫为什么要用基于事件来写的原因。</p>

<p>这里需要理解爬虫这种程序的本质，它是网络I/O密集程序，不是CPU密集，而处理I/O密集最高效的做法就是事件循环。</p>

<p>所以我做的一个做大的改善就是把原来的阻塞爬虫改成了基于事件的爬虫，它得到的好处是可以完全把带宽跑满，爬取速度最大化。</p>

<p>除此之外，还有一个改善是把多线程模型改成了单进程模型。有同学可能会产生疑惑，难道利用多核还会比单核性能差？我们从以下两点来分析：</p>

<ol>
<li><p>根据amdahl定律，对系统中一个模块的加速，不仅取决于加速比，还取决于这个模块在原来系统中占的比例。爬虫是I/O密集程序，绝大部分时间都花在了网络I/O上，CPU大部分时间是空闲的，所以提高CPU的利用率其实效果很小。</p></li>
<li><p>多线程会引入额外的开销，最大的开销可能就是锁了。比如你要把新的URL加入队列，这时候在多线程环境下肯定要对队列加锁。</p></li>
</ol>


<p>那么问题就是，第一点所带来的性能提升和第二点所带来的开销，哪个更大一点？如果第二点大，我们果断要换成单进程。答案是看环境，我们极端点看，如果你的带宽无穷大，网络情况无穷好，那么请求一发出去立刻就回复了，这个网络I/O密集程序硬生生变成了CPU密集，多线程会好；如果你的带宽无穷小，那么锁带来的开销会占比更大，一个任务来了多线程之间还要竞争一下，单线程就直接处理了且没有锁的性能开销，用单线程会好。我们需要在不同的环境下选择最好的办法，不过一般来说，现实中最大的时间开销一定在网络I/O。</p>

<h2>用C++实现爬虫时的难点</h2>

<ol>
<li><p>从TCP socket读取数据到把完整的HTML数据交付上层需要一个数据层，因为如果调用read返回<a href="http://stackoverflow.com/questions/4058368/what-does-eagain-mean">EAGAIN</a>时，这时是不知道到底有没有接受到完整的HTML，需要保存好当前读到的网页内容，并通过一个状态机来解析当前收到的数据，保存当前的状态，如果解析完成（读到全部数据了）就返回SUCCESS，否则就就返回ERROR，等待下一次数据来临，继续解析状态机。用动态语言不需要考虑这一点，会直接传递给用户层完整的数据。</p></li>
<li><p>请求得太快，知乎会返回429错误（即提示客户请求太多，稍后再试），这个问题怎么解决？乖乖地等待一段时间再去抓是一种浪费带宽的行为。服务器判断请求太多是看这个IP在一段时间的请求数太多了，如果我们IP分散为N个不同IP，那就解决这个问题了。这个方案叫动态IP或者代理IP。那么多IP意味着要花很多的钱，如果不愿意花钱，还是乖乖等一段时间再发请求吧。</p></li>
<li><p>爬虫里一个需求，要获得一个用户的所有关注的人和关注者，但这些东西都是通过ajax获取的，所以要写一个post请求来模拟ajax。其中post data里有一个hash_id和_xsrf，这两个值都在哪里可以获得？后来在该用户的主页的HTML里找到了这两个值。</p></li>
<li><p>怎么用C++解析HTML？比如上面一点提到的，我要找到这个页面里的hash_id，它可能是某个HTML元素的属性，怎么得到这个属性值？用过JQuery的同学这时会想，如果C++里面也有一个像JQuery那么好用的库该多好，直接写个选择器就获得属性的值了。我简单地调研了一下，C++还是有这样的库的。基于学习的目的，最好自己写一个这样的库，所以，问题来了，怎么实现一个HTML parser？或者更简单的，怎么实现一个正则匹配？</p></li>
<li><p>如何管理一个请求的周期，因为一个请求的周期中，状态太多了。为什么状态多，因为一个请求会涉及很多异步操作，首先获取该用户的答案页面，这时候要等待server的回复，处理完以后获得改用户所有关注的人和关注者的页面，也要等待server的回复，再把这些所有用户加入队列后，这个请求周期才算结束。</p></li>
<li><p>需要自己处理一些HTTP header的细节。比如不希望接受到HTTP response header里Transfer Encoding: chuncked回复，因为它显然没有Content-length直接获取到数据长度来得方便，该怎么办？再比如不希望接受到gzip处理过的数据，希望收到plain text，又该怎么办？</p></li>
<li><p>架构怎么设计。首先最底层是TCP层，上层应该封装一个数据接收层，再上层应该是HTML解析层，最后是事件循环层。这些层次/模块怎么做到耦合度最低？</p></li>
<li><p>网络异常怎么处理，比如read返回error（eg  Connection reset by peer），或者EOF。EOF需要重新建立一个新的连接，然后继续前一个请求（或者说继续状态机）。</p></li>
</ol>


<h2>用C++相比Python，NodeJS的优点</h2>

<ol>
<li><p>系统的掌控性。比如我们希望TCP连接数要控制在1000，完全可能很容易地实现。并且可以知道哪里会耗内存、CPU，底层在发生什么我们更容易知道。比如，在HTTP request header里写上<code>Connection: keep-alive</code>可以让很多请求复用一个TCP连接，在用C++实现的时候，对应的实现方法很简单粗暴：从socket读完对方服务器发来的response后，再构造一个header发过去即可。</p></li>
<li><p>因为一些内建库的缺乏，并且出发点是学习，我们会重新造一些轮子，与此同时，提高了编程能力。
比如说读配置文件，格式是json，可以自己用C写个json parser。再比如上文提到的HTML parser，也可以用C写一个，还有基于epoll的事件循环，可以抽象成一个通用的网络库。有太多轮子可以造，要把其中任意一个轮子写好都是非常难的事情。</p></li>
<li><p>高性能。可能由于网络的大延迟使得这个优点不那么明显。</p></li>
</ol>


<h2>总结</h2>

<p>本文基于我一年多之前写的zhihu爬虫以及最近的大规模改进，总结了如何用C++编写的高效、基于事件驱动的知乎爬虫，同时也列出了用C++写爬虫时的一些难点与收获。</p>

<p>如果你有兴趣看看竟然有人用C++写了一个爬虫究竟是什么样子的，代码在<a href="https://github.com/zyearn/zhihuCrawler">这里</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何写一个Web服务器]]></title>
    <link href="http://zyearn.github.io/blog/2015/05/16/how-to-write-a-server/"/>
    <updated>2015-05-16T17:39:00+02:00</updated>
    <id>http://zyearn.github.io/blog/2015/05/16/how-to-write-a-server</id>
    <content type="html"><![CDATA[<p>最近两个月的业余时间在写一个私人项目，目的是在Linux下写一个高性能Web服务器，名字叫Zaver。主体框架和基本功能已完成，还有一些高级功能日后会逐渐增加，代码放在了<a href="https://github.com/zyearn/zaver" target="_blank">github</a>。Zaver的框架会在代码量尽量少的情况下接近工业水平，而不像一些教科书上的toy server为了教原理而舍弃了很多原本server应该有的东西。
在本篇文章中，我将一步步地阐明Zaver的设计方案和开发过程中遇到的困难以及相应的解决方法。</p>

<!-- more -->


<h2>为什么要重复造轮子</h2>

<p>几乎每个人每天都要或多或少和Web服务器打交道，比较著名的Web Server有Apache Httpd、Nginx、IIS。这些软件跑在成千上万台机器上为我们提供稳定的服务，当你打开浏览器输入网址，Web服务器就会把信息传给浏览器然后呈现在用户面前。那既然有那么多现成的、成熟稳定的web服务器，为什么还要重新造轮子，我认为理由有如下几点：</p>

<ul>
<li><p>夯实基础。一个优秀的开发者必须有扎实的基础，造轮子是一个很好的途径。学编译器？边看教材变写一个。学操作系统？写一个原型出来。编程这个领域只有自己动手实现了才敢说真正会了。现在正在学网络编程，所以就打算写一个Server。</p></li>
<li><p>实现新功能。成熟的软件可能为了适应大众的需求导致不会太考虑你一个人的特殊需求，于是只能自己动手实现这个特殊需求。关于这一点Nginx做得相当得好了，它提供了让用户自定义的模块来定制自己需要的功能。</p></li>
<li><p>帮助初学者容易地掌握成熟软件的架构。比如Nginx，虽然代码写得很漂亮，但是想完全看懂它的架构，以及它自定义的一些数据结构，得查相当多的资料和参考书籍，而这些架构和数据结构是为了提高软件的可伸缩性和效率所设计的，无关高并发server的本质部分，初学者会迷糊。而Zaver用最少的代码展示了一个高并发server应有的样子，虽然没有Nginx性能高，得到的好处是没有Nginx那么复杂，server架构完全展露在用户面前。</p></li>
</ul>


<h2>教科书上的server</h2>

<p>学网络编程，第一个例子可能会是Tcp echo服务器。
大概思路是server会listen在某个端口，调用accept等待客户的connect，等客户连接上时会返回一个fd(file descriptor)，从fd里read，之后write同样的数据到这个fd，然后重新accept，在网上找到一个非常好的代码实现，核心代码是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*  Wait for a connection, then accept() it  */</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">conn_s</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">list_s</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;ECHOSERV: Error calling accept()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*  Retrieve an input line from the connected socket</span>
</span><span class='line'><span class="cm">        then simply write it back to the same socket.     */</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Readline</span><span class="p">(</span><span class="n">conn_s</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">MAX_LINE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="n">Writeline</span><span class="p">(</span><span class="n">conn_s</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*  Close the connected socket  */</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span> <span class="n">close</span><span class="p">(</span><span class="n">conn_s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;ECHOSERV: Error calling close()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>完整实现在<a href="http://www.paulgriffiths.net/program/c/srcs/echoservsrc.html" target="_blank">这里</a>。如果你还不太懂这个程序，可以把它下载到本地编译运行一下，用telnet测试，你会发现在telnet里输入什么，马上就会显示什么。如果你之前还没有接触过网络编程，可能会突然领悟到，这和浏览器访问某个网址然后信息显示在屏幕上，整个原理是一模一样的！
学会了这个echo服务器是如何工作的以后，在此基础上拓展成一个web server非常简单，因为HTTP是建立在TCP之上的，无非多一些协议的解析。client在建立TCP连接之后发的是HTTP协议头和（可选的）数据，server接受到数据后先解析HTTP协议头，根据协议头里的信息发回相应的数据，浏览器把信息展现给用户,一次请求就完成了。</p>

<p>这个方法是一些书籍教网络编程的标准例程，比如《深入理解计算机系统》（CSAPP）在讲网络编程的时候就用这个思路实现了一个最简单的server，代码结构和上面的echo服务器代码类似，完整实现在<a href="http://csapp.cs.cmu.edu/public/ics2/code/netp/tiny/tiny.c" target="_blank">这里</a>，非常短，值得一读，特别是这个server即实现了静态内容又实现了动态内容，虽然效率不高，但已达到教学的目的。之后这本书用事件驱动优化了这个server，关于事件驱动会在后面讲。</p>

<p>虽然这个程序能正常工作，但它完全不能投入到工业使用，原因是server在处理一个客户请求的时候无法接受别的客户，也就是说，这个程序无法同时满足两个想得到echo服务的用户，这是无法容忍的，试想一下你在用微信，然后告诉你有人在用，你必须等那个人走了以后才能用。</p>

<p>然后一个改进的解决方案被提出来了：accept以后fork，父进程继续accept，子进程来处理这个fd。这也是一些教材上的标准示例，代码大概长这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* Main loop */</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">their_addr</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">);</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">newsock</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">their_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">newsock</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">perror</span><span class="p">(</span><span class="s">&quot;accept&quot;</span><span class="p">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="cm">/* In child process */</span>
</span><span class='line'>            <span class="n">close</span><span class="p">(</span><span class="n">listenfd</span><span class="p">);</span>
</span><span class='line'>            <span class="n">handle</span><span class="p">(</span><span class="n">newsock</span><span class="p">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="cm">/* Parent process */</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">perror</span><span class="p">(</span><span class="s">&quot;fork&quot;</span><span class="p">);</span>
</span><span class='line'>                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">close</span><span class="p">(</span><span class="n">newsock</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>完整代码在<a href="http://www.martinbroadhurst.com/source/forked-server.c.html" target="_blank">这里</a>。表面上，这个程序解决了前面只能处理单客户的问题，但基于以下几点主要原因，还是无法投入工业的高并发使用。</p>

<ul>
<li>每次来一个连接都fork，开销太大。任何讲Operating System的书都会写，线程可以理解为轻量级的进程，那进程到底重在什么地方？《Linux Kernel Development》有一节（<a href="http://www.makelinux.net/books/lkd2/ch03lev1sec2" target="_blank">Chapter3</a>）专门讲了调用fork时，系统具体做了什么。地址空间是copy on write的，所以不造成overhead。但是其中有一个复制父进程页表的操作，这也是为什么在Linux下创建进程比创建线程开销大的原因，而所有线程都共享一个页表（关于为什么地址空间是COW但页表不是COW的原因，可以思考一下）。</li>
</ul>


<!-- 
http://www.quora.com/While-forking-a-process-why-does-Linux-kernel-copy-the-content-of-kernel-page-table-for-every-newly-created-process
http://stackoverflow.com/questions/16724641/the-only-overhead-incurred-by-fork-is-page-table-duplication-and-process-id-crea 
-->


<ul>
<li><p>进程调度器压力太大。当并发量上来了，系统里有成千上万进程，相当多的时间将花在决定哪个进程是下一个运行进程以及上下文切换，开销非常大，具体的分析请看<a href="http://www.cs.berkeley.edu/~culler/papers/events.pdf">《A Design Framework for Highly Concurrent Systems》</a>。</p></li>
<li><p>在heavy load下多个进程消耗太多的内存，在进程下，每一个连接都对应一个独立的地址空间；即使在线程下，每一个连接也会占用独立。此外父子进程之间需要发生IPC，高并发下IPC带来的overhead不可忽略。</p></li>
</ul>


<p>换用线程虽然能解决fork开销的问题，但是调度器和内存的问题还是无法解决。所以进程和线程在本质上是一样的，被称为process-per-connection model。因为无法处理高并发而不被业界使用。</p>

<p>一个非常显而易见的改进是用线程池，线程数量固定，就没上面提到的问题了。基本架构是有一个loop用来accept连接，之后把这个连接分配给线程池中的某个线程，处理完了以后这个线程又可以处理别的连接。看起来是个非常好的方案，但在实际情况中，很多连接都是长连接（在一个TCP连接上进行多次通信），一个线程在收到任务以后，处理完第一批来的数据，此时会再次调用read，天知道对方什么时候发来新的数据，于是这个线程就被这个read给阻塞住了（因为默认情况下fd是blocking的，即如果这个fd上没有数据，调用read会阻塞住进程），什么都不能干，假设有n个线程，第(n+1)个长连接来了，还是无法处理。</p>

<p>怎么办？我们发现问题是出在read阻塞住了线程，所以解决方案是把blocking I/O换成non-blocking I/O，这时候read的做法是如果有数据则返回数据，如果没有可读数据就返回-1并把errno设置为EAGAIN，表明下次有数据了我再来继续读(man 2 read)。</p>

<p>这里有个问题，进程怎么知道这个fd什么时候来数据又可以读了？这里要引出一个关键的概念，事件驱动/事件循环。</p>

<h2>事件驱动(Event-driven)</h2>

<p>如果有这么一个函数，在某个fd可以读的时候告诉我，而不是反复地去调用read，上面的问题不就解决了？这种方式叫做事件驱动，在linux下可以用select/poll/epoll这些I/O复用的函数来实现（man 7 epoll），因为要不断知道哪些fd是可读的，所以要把这个函数放到一个loop里，这个就叫事件循环（event loop）。示例代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">timeout_ms</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">getNextTimedCallback</span><span class="p">());</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epds</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">,</span> <span class="n">timeout_ms</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="err">处理错误</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="err">处理到期的</span> <span class="n">timers</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="err">处理</span> <span class="n">IO</span> <span class="err">事件</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这个while里，调用<code>epoll_wait</code>会将进程阻塞住，直到在epoll里的fd发生了当时注册的事件。
<a href="https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/" target="_blank">这里</a>有个非常好的例子来展示epoll是怎么用的。
需要注明的是，select/poll不具备伸缩性，复杂度是O(n)，而epoll的复杂度是O(1)，在Linux下工业程序都是用epoll（其它平台有各自的API，比如在Freebsd/MacOS下用kqueue）来通知进程哪些fd发生了事件，至于为什么epoll比前两者效率高，请参考<a href="http://stackoverflow.com/questions/17355593/why-is-epoll-faster-than-select" target="_blank">这里</a>。</p>

<p>事件驱动是实现高性能服务器的关键，像Nginx，lighttpd，Tornado，NodeJs都是基于事件驱动实现的。</p>

<h2>Zaver</h2>

<p>结合上面的讨论，我们得出了一个事件循环+ non-blocking I/O + 线程池的解决方案，这也是Zaver的主题架构（同步的事件循环+non-blocking I/O又被称为<a href="http://en.wikipedia.org/wiki/Reactor_pattern" target="_blank">Reactor</a>模型）。
事件循环用作事件通知，如果listenfd上可读，则调用accept，把新建的fd加入epoll中；是普通的连接fd，将其加入到一个生产者-消费者队列里面，等工作线程来拿。
线程池用来做计算，从一个生产者-消费者队列里拿一个fd作为计算输入，直到读到EAGAIN为止，保存现在的处理状态（状态机），等待事件循环对这个fd读写事件的下一次通知。</p>

<h2>开发中遇到的问题</h2>

<p>Zaver的运行架构在上文介绍完毕，下面将总结一下我在开发时遇到的一些困难以及一些解决方案。
把开发中遇到的困难记录下来是个非常好的习惯，如果遇到问题查google找到个解决方案直接照搬过去，不做任何记录，也没有思考，那么下次你遇到同样的问题，还是会重复一遍搜索的过程。有时我们要做代码的创造者，不是代码的“搬运工”。做记录定期回顾遇到的问题会使自己成长更快。</p>

<ul>
<li>如果将fd放入生产者-消费者队列中后，拿到这个任务的工作线程还没有读完这个fd，因为没读完数据，所以这个fd可读，那么下一次事件循环又返回这个fd，又分给别的线程，怎么处理？</li>
</ul>


<p>答：这里涉及到了epoll的两种工作模式，一种叫边缘触发（Edge Triggered），另一种叫水平触发（Level Triggered）。ET和LT的命名是非常形象的，ET是表示在状态改变时才通知（eg，在边缘上从低电平到高电平），而LT表示在这个状态才通知（eg，只要处于低电平就通知），对应的，在epoll里，ET表示只要有新数据了就通知（状态的改变）和“只要有新数据”就一直会通知。</p>

<p>举个具体的例子：如果某fd上有2kb的数据，应用程序只读了1kb，ET就不会在下一次epoll_wait的时候返回，读完以后又有新数据才返回。而LT每次都会返回这个fd，只要这个fd有数据可读。所以在Zaver里我们需要用epoll的ET，用法的模式是固定的，把fd设为nonblocking，如果返回某fd可读，循环read直到EAGAIN（如果read返回0，则远端关闭了连接）。</p>

<ul>
<li>如果某个线程在处理fd的同时，又有新的一批数据发来，该fd可读（注意和上面那个问题的区别，一个是处理同一批数据时，一个是处理新来的一批数据），那么该fd会被分给另一个线程，这样两个线程处理同一个fd肯定就不对了。</li>
</ul>


<p>答：用EPOLLONESHOT解决这个问题。在fd返回可读后，需要显式地设置一下才能让epoll重新返回这个fd。</p>

<ul>
<li>当server和浏览器保持着一个长连接的时候，1)浏览器突然被关闭了，2)断电了/被拔网线了，那么server端怎么处理这个socket？</li>
</ul>


<p>答：对于1)，此时该fd在事件循环里会返回一个可读事件，然后就被分配给了某个线程，该线程read会返回0，代表对方已关闭这个fd，于是server端也调用close即可。对于2)，协议栈无法感知，SO_KEEPALIVE超时时间太长不适用，所以只能通过应用层timer超时事件解决。</p>

<ul>
<li>如何设计和实现timer？</li>
</ul>


<p>答：Nginx把timer实现成了rbtree，这就很奇怪，timer模块需要频繁找最小的key（最早超时的事件）然后处理后删除，这个场景下难道不是最小化堆是最好的数据结构么？然后通过<a href="http://tengine.taobao.org/download/programmer-201209-Tengine.pdf">搜索</a>得知阿里的Tengine将timer的实现了4-heap（四叉最小堆）。四叉堆是二叉堆的变种，比二叉堆有更浅的深度和更好的CPU Cache命中率。Tengine团队声称用最小堆性能提升比较明显。在Zaver中为了简化实现，使用了二叉堆来实现timer的功能。</p>

<ul>
<li>把fd设置为non-blocking后，while循环需要不断地read直到返回-1，errno为EAGAIN，然后等待下次epoll_wait返回这个fd再继续处理。这时就遇到了一个blocking read不曾遇到的问题：数据可能分包到达，于是在协议解析到一半的时候read就返回-1，所以我们必须将已读到的数据保存下来，并维护一个状态，以表示是否还需要数据，比如解析HTTP Request Header的时候, 读到<code>GET /index.html HTT</code>就结束了，在blocking I/O里只要继续read就可以，但在nonblocking I/O，我们必须维护这个状态，下一次必须读到'P'，否则HTTP协议解析错误。</li>
</ul>


<p>答：解决方案是维护一个状态机，在解析Request Header的时候对应一个状态机，解析Header Body的时候也维护一个状态机，Zaver状态机的时候参考了Nginx在解析header时的实现，我做了一些精简和设计上的改动。</p>

<ul>
<li>怎么较好的实现header的解析</li>
</ul>


<p>答：HTTP header有很多，必然有很多个解析函数，比如解析<code>If-modified-since</code>头和解析<code>Connection</code>头是分别调用两个不同的函数，所以这里的设计必须是一种模块化的、易拓展的设计，可以使开发者很容易地修改和定义针对不同header的解析。Zaver的实现方式参考了Nginx的做法，定义了一个struct数组，其中每一个struct存的是key，和对应的函数指针hock，如果解析到的headerKey == key，就调hock。定义代码如下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">zv_http_header_handle_t</span> <span class="n">zv_http_headers_in</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">{</span><span class="s">&quot;Host&quot;</span><span class="p">,</span> <span class="n">zv_http_process_ignore</span><span class="p">},</span>
</span><span class='line'>    <span class="p">{</span><span class="s">&quot;Connection&quot;</span><span class="p">,</span> <span class="n">zv_http_process_connection</span><span class="p">},</span>
</span><span class='line'>    <span class="p">{</span><span class="s">&quot;If-Modified-Since&quot;</span><span class="p">,</span> <span class="n">zv_http_process_if_modified_since</span><span class="p">},</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">zv_http_process_ignore</span><span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>怎样存储header</li>
</ul>


<p>答：Zaver将所有header用链表连接了起来，链表的实现参考了Linux内核的双链表实现（list_head），它提供了一种通用的双链表数据结构，代码非常值得一读，我做了简化和改动，代码在<a href="https://github.com/zyearn/zaver/blob/master/src/list.h" target="_blank">这里</a>。</p>

<ul>
<li>压力测试</li>
</ul>


<p>答：压力测试为了测量网站对高并发的承受程度，在哪个并发度会使网站挂掉。这个有很多成熟的方案了，比如http_load, webbench, ab等等。我最终选择了<a href="http://home.tiscali.cz/~cz210552/webbench.html" target="_blank">webbench</a>，理由是简单，用fork来模拟client，代码只有几百行，出问题可以马上根据webbench源码定位到底是哪个操作使Server挂了，这就说到了我在做压力测试时遇到一个问题，然后看了一下Webbench的源码，就很快找到了问题所在（并且非常推荐C初学者看一看它的源码，只有几百行，但是涉及了命令行参数解析、fork子进程、父子进程用pipe通信、信号handler的注册、构建HTTP协议头的技巧等一些编程上的技巧）。</p>

<p>之前提到的那个问题是：用Webbech测试，Server在测试结束时挂了。</p>

<p>百思不得其解，不管时间跑多久，并发量开多少，都是在最后webbench结束的时刻，server挂了，所以我猜想肯定是这一刻发生了什么“事情”。
开始调试定位错误代码，我用的是打log的方式，后面的事实证明在这里这不是很好的方法，在多线程环境下要通过看log的方式定位错误是一件比较困难的事。最后log输出把错误定位在向socket里write对方请求的文件，也就是系统调用挂了，write挂了难道不是返回-1的吗？于是唯一的解释就是进程接受到了某signal，这个signal使进程挂了。于是用strace重新进行测试，在strace的输出log里发现了问题，系统在write的时候接受到了SIGPIPE，默认的signal handler是终止进程。SIGPIPE产生的原因为，对方已经关闭了这个socket，但进程还往里面写。所以我猜想webbench在测试时间到了之后不会等待server数据的返回直接close掉所有的socket。抱着这样的怀疑去看webbench的源码，果然是这样的，webbench设置了一个定时器，在正常测试时间会读取server返回的数据，并正常close；而当测试时间一到就直接close掉所有socket，不会读server返回的数据，这就导致了zaver往一个已被对方关闭的socket里写数据，系统发送了SIGPIPE。</p>

<p>解决方案也非常简单，把SIGPIPE的信号handler设置为SIG_IGN，忽略该信号即可。</p>

<h2>不足</h2>

<p>目前Zaver还有很多改进的地方，比如：</p>

<ul>
<li>现在新分配内存都是通过malloc的方式，之后会改成内存池的方式</li>
<li>还不支持动态内容，后期开始考虑增加php的支持</li>
<li>HTTP/1.1较复杂，目前只实现了几个主要的（keep-alive, browser cache）的header解析</li>
<li>不活动连接的超时过期还没有做</li>
<li>&hellip;</li>
</ul>


<h2>总结</h2>

<p>本文介绍了Zaver，一个结构简单，支持高并发的http服务器。
基本架构是事件循环 + non-blocking I/O + 线程池。
Zaver的代码风格参考了Nginx的风格，所以在可读性上非常高。另外，Zaver提供了配置文件和命令行参数解析，以及完善的Makefile和源代码结构，也可以帮助任何一个C初学者入门一个项目是怎么构建的。</p>

<h2>参考资料</h2>

<p>[1] <a href="https://github.com/zyearn/zaver">https://github.com/zyearn/zaver</a> <br>
[2] <a href="http://nginx.org/en/">http://nginx.org/en/</a> <br>
[3] 《linux多线程服务端编程》 <br>
[4] <a href="http://www.martinbroadhurst.com/server-examples.html">http://www.martinbroadhurst.com/server-examples.html</a> <br>
[5] <a href="http://berb.github.io/diploma-thesis/original/index.html">http://berb.github.io/diploma-thesis/original/index.html</a> <br>
[6] <a href="http://tools.ietf.org/html/rfc2616" target="_blank">rfc2616</a> <br>
[7] <a href="https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/">https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/</a> <br>
[8] Unix Network Programming, Volume 1: The Sockets Networking API (3rd Edition)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[当执行kill -9 PID时系统发生了什么]]></title>
    <link href="http://zyearn.github.io/blog/2015/03/22/what-happens-when-you-kill-a-process/"/>
    <updated>2015-03-22T20:46:00+01:00</updated>
    <id>http://zyearn.github.io/blog/2015/03/22/what-happens-when-you-kill-a-process</id>
    <content type="html"><![CDATA[<p>我们时常遇到这样的需求：要杀死一个正在运行运行的进程。这时候可以在终端输入</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>kill -9 &lt;PID&gt;</span></code></pre></td></tr></table></div></figure>


<p>（其中9的意思是SIGKILL，完整的linux信号请看<a href="http://www.comptechdoc.org/os/linux/programming/linux_pgsignals.html">这里</a>）之后你再用ps查看进程的时候，会发现那个进程已经被杀掉了。</p>

<!-- more -->


<p>本文将说明在LINUX系统下，用户在终端输入<code>kill -9 &lt;PID&gt;</code>之后，整个系统到底发生了什么，我们将深入到内核代码。一开始我在想这个问题的时候遇到了一些问题，比如进程是怎么知道自己收到信号的？在执行进程工作代码的同时还要不断轮询有没有新到的信号吗？代价也太大了吧？那是不是基于什么异步通知的方案呢？在说明LINUX是怎么做的之前，先解释一点基础的概念。</p>

<h2>什么是信号（SIGNAL）</h2>

<p>我自己的理解：信号之于进程，就好比中断之于CPU，是一种信息传递的方式。官方的解释是A signal is an asynchronous notification sent to a process or to a specific thread within the same process in order to notify it of an event that occurred.
一个程序在运行的时候，你可以发各种信号给这个进程，进程对这个信号做出响应。比如你发个SIGKILL给一个进程，该进程就知道用户要杀死它，然后就会终止进程。
一个更常见的例子，你在终端运行一个进程以后，如果是非后台进程，它会在console输出一些log，这时候shell也不能接受输入了，这时候你按下<code>control+c</code>，进程就被终止了，在这个过程中你就给这个进程发送了一个信号（SIGINT，interrupt signal），在默认情况下，是终止改进程。
那什么时候是非默认情况呢？这里需要引入信号处理器（signal handler）的概念，你可以为一部分信号编写特定的处理函数，比如在默认情况下，SIGINT是结束进程，你可以修改这个默认行为使它什么都不做（即一个空函数），但是有些信号的行为是无法修改的，比如SIGKILL。</p>

<h2>kill 命令</h2>

<p>在LINUX下有一个<code>kill</code>的命令，第一次用的同学会以为这是一个“杀死”某个进程的命令，其实并不是很准确。这个命令的作用就是给指定PID的进程发送信号，到底发送什么信号也是由参数指定的，如果不指定信号，默认是发送SIGTERM，它的默认行为是终止进程。其实<code>kill</code>也是个程序，它内部会调用system call的kill来发起真正信号传递过程。
更详细的介绍请<code>man 2 kill</code></p>

<h2>shell fork进程</h2>

<p>当你敲下命令，按下回车，程序就执行了，其实这里也是个很复杂的过程。涉及到了shell的运行原理，每一个shell的实现都不一样，但核心原理是不变的：<code>fork</code>一个子进程，再调用<code>execve</code>那一系列系统调用。想了解一个shell是怎么写的，我觉得最好的资料是《Unix/Linux编程实践教程》第八章。本文不会详细解释<code>shell/fork/execve</code>，我会在另一篇博客里详细解释当你执行<code>fork</code>时，系统发生了什么。</p>

<p>好了，基础知识差不多介绍完了，下面我们进入下一阶段。</p>

<h2>kill -9 PID</h2>

<p>我们先讲原理再深入实现细节。所有内核代码都基于3.16.3，本文出现的所有内核代码是我删除了一些错误处理，加锁，临界判断后的结果，所以是比较核心的代码。</p>

<p>执行<code>kill -9 &lt;PID&gt;</code>，进程是怎么知道自己被发送了一个信号的？首先要产生信号，执行kill程序需要一个pid，根据这个pid找到这个进程的task_struct（这个是Linux下表示进程/线程的结构），然后在这个结构体的特定的成员变量里记下这个信号。
这时候信号产生了但还没有被特定的进程处理，叫做Pending signal。
等到下一次CPU调度到这个进程的时候，内核会保证先执行<code>do\_signal</code>这个函数看看有没有需要被处理的信号，若有，则处理；若没有，那么就直接继续执行该进程。所以我们看到，在Linux下，信号并不像中断那样有异步行为，而是每次调度到这个进程都是检查一下有没有未处理的信号。</p>

<p>当然信号的产生不仅仅在终端kill的时候才产生的。总结起来，大概有如下三种产生方式：</p>

<ul>
<li>硬件异常：比如除0</li>
<li>软件通知：比如当你往一个已经被对方关闭的管道中写数据的时候，会发生SIGPIPE</li>
<li>终端信号：你输入<code>kill -9 &lt;PID&gt;</code>，或者<code>control+c</code>就是这种类型</li>
</ul>


<p>大概原理就是这个样子的，接下来我们来看一看内核的实现。</p>

<h2>实现</h2>

<p>首先，你在shell里输入<code>kill</code>这个命令，它本身就是个程序，是有源代码的，它的代码可以在Linux的<a href="http://git.savannah.gnu.org/cgit/coreutils.git/tree/src/">coreutils</a>里找到。代码很长，我就不全复制过来了，有兴趣的可以去仔细看看。它的核心代码是长这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static int
</span><span class='line'>send_signals (int signum, char *const *argv)
</span><span class='line'>{
</span><span class='line'>    ...
</span><span class='line'>    kill (pid, signum);
</span><span class='line'>    ...
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int
</span><span class='line'>main (int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>    ...
</span><span class='line'>    send_signals (signum, argv + optind));
</span><span class='line'>    ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们看到最后调用了系统调用<code>kill</code>，其代码在Linux内核<code>linux-3.16.3/kernel/signal.c</code>中实现。在看kill源码之前，先把这个函数最终要操作的结构体看一下，这个struct很长，只列出了信号相关的部分：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct task_struct {
</span><span class='line'>    ...
</span><span class='line'>/* signal handlers */
</span><span class='line'>  struct signal_struct *signal; /* 一个进程所有线程共享一个signal */
</span><span class='line'>  struct sighand_struct *sighand; 
</span><span class='line'>
</span><span class='line'>  sigset_t blocked, real_blocked; /* 哪些信号被阻塞了 */
</span><span class='line'>  sigset_t saved_sigmask; /* restored if set_restore_sigmask() was used */
</span><span class='line'>  struct sigpending pending; /* 进程中的多个线程有各自的pending */
</span><span class='line'>    ...
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>继续看kill系统调用，我将核心代码列在了下面，想看完整版的点<a href="http://lxr.free-electrons.com/source/kernel/signal.c#L2893">这里</a>。为了方便理解，我给核心逻辑增加了注释。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)
</span><span class='line'>{
</span><span class='line'>    ...
</span><span class='line'>    return kill_something_info(sig, &info, pid);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static int kill_something_info(int sig, struct siginfo *info, pid_t pid)
</span><span class='line'>{
</span><span class='line'>  int ret;
</span><span class='line'>
</span><span class='line'>    // 如果pid大于0，就把信号发送给指定的进程
</span><span class='line'>  if (pid &gt; 0) {
</span><span class='line'>      ret = kill_pid_info(sig, info, find_vpid(pid));
</span><span class='line'>      return ret;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>    // 如果pid &lt;=0 并且不等于-1，发送信号给-pid指定的进程组
</span><span class='line'>  if (pid != -1) {
</span><span class='line'>      ret = __kill_pgrp_info(sig, info,
</span><span class='line'>              pid ? find_vpid(-pid) : task_pgrp(current));
</span><span class='line'>  } else {    
</span><span class='line'>        //否则发信号给除自己所属进程之外的其它所有进程
</span><span class='line'>      int retval = 0, count = 0;
</span><span class='line'>      struct task_struct * p;
</span><span class='line'>
</span><span class='line'>      for_each_process(p) {
</span><span class='line'>          if (task_pid_vnr(p) &gt; 1 &&
</span><span class='line'>                  !same_thread_group(p, current)) {
</span><span class='line'>              int err = group_send_sig_info(sig, info, p);
</span><span class='line'>              ++count;
</span><span class='line'>              if (err != -EPERM)
</span><span class='line'>                  retval = err;
</span><span class='line'>          }
</span><span class='line'>      }
</span><span class='line'>      ret = count ? retval : -ESRCH;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  return ret;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>因为这个<code>kill_something_info</code>函数会根据pid的正负来决定是发给特定的进程还是一个进程组，我们下面主要来看发给一个特定进程的情况，即调用<code>kill_pid_info</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int kill_pid_info(int sig, struct siginfo *info, struct pid *pid)
</span><span class='line'>{
</span><span class='line'>  int error = -ESRCH;
</span><span class='line'>  struct task_struct *p;
</span><span class='line'>   
</span><span class='line'>  p = pid_task(pid, PIDTYPE_PID);
</span><span class='line'>  if (p) {
</span><span class='line'>      error = group_send_sig_info(sig, info, p);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  return error;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>注意这个函数，出现了我们上文提到的<code>task_strcut</code>，这个是Linux下表示每个进程/线程的结构体，根据<code>struct pid</code>找到这个结构后，就调用了<code>group_send_sig_info</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p)
</span><span class='line'>{
</span><span class='line'>  int ret;
</span><span class='line'>
</span><span class='line'>    ret = do_send_sig_info(sig, info, p, true);
</span><span class='line'>
</span><span class='line'>  return ret;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>int do_send_sig_info(int sig, struct siginfo *info, struct task_struct *p,
</span><span class='line'>          bool group)
</span><span class='line'>{
</span><span class='line'>  unsigned long flags;
</span><span class='line'>  int ret = -ESRCH;
</span><span class='line'>
</span><span class='line'>  if (lock_task_sighand(p, &flags)) {
</span><span class='line'>      ret = send_signal(sig, info, p, group);
</span><span class='line'>      unlock_task_sighand(p, &flags);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  return ret;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>static int send_signal(int sig, struct siginfo *info, struct task_struct *t,
</span><span class='line'>          int group)
</span><span class='line'>{
</span><span class='line'>  int from_ancestor_ns = 0;
</span><span class='line'>
</span><span class='line'>#ifdef CONFIG_PID_NS
</span><span class='line'>  from_ancestor_ns = si_fromuser(info) &&
</span><span class='line'>             !task_pid_nr_ns(current, task_active_pid_ns(t));
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>  return __send_signal(sig, info, t, group, from_ancestor_ns);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>static int __send_signal(int sig, struct siginfo *info, struct task_struct *t,
</span><span class='line'>          int group, int from_ancestor_ns)
</span><span class='line'>{
</span><span class='line'>  struct sigpending *pending;
</span><span class='line'>  struct sigqueue *q;
</span><span class='line'>  int override_rlimit;
</span><span class='line'>  int ret = 0, result;
</span><span class='line'>
</span><span class='line'>    // 发送给进程和线程的区别在这里，如果是进程，则&t-&gt;signal-&gt;shared_pending，否则&t-&gt;pending
</span><span class='line'>  pending = group ? &t-&gt;signal-&gt;shared_pending : &t-&gt;pending;
</span><span class='line'>
</span><span class='line'>  /*
</span><span class='line'>   * fast-pathed signals for kernel-internal things like SIGSTOP
</span><span class='line'>   * or SIGKILL.
</span><span class='line'>   */
</span><span class='line'>  if (info == SEND_SIG_FORCED)
</span><span class='line'>      goto out_set;
</span><span class='line'>    
</span><span class='line'>    ...
</span><span class='line'>
</span><span class='line'>out_set:
</span><span class='line'>    // 把信号通知listening signalfd. 
</span><span class='line'>  signalfd_notify(t, sig);
</span><span class='line'>
</span><span class='line'>    // 将sig加入目标进程的信号位图中，待下一次CPU调度的时候读取
</span><span class='line'>  sigaddset(&pending-&gt;signal, sig);
</span><span class='line'>
</span><span class='line'>    // 用于决定由哪个进程/线程处理该信号，然后wake_up这个进程/线程
</span><span class='line'>  complete_signal(sig, t, group);
</span><span class='line'>ret:
</span><span class='line'>  trace_signal_generate(sig, info, t, group, result);
</span><span class='line'>  return ret;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到，最终调用到<code>__send_signal</code>，设置信号的数据结构，wake up需要处理信号的进程，整个信号传递的过程就结束了。这时候信号还没有被进程处理，还是一个pending signal。</p>

<h2>信号的处理</h2>

<p>内核调度到该进程时，会调用<code>do_notify_resume</code>来处理信号队列中的信号，之后这个函数又会调用<code>do_signal</code>，再调用<code>handle_signal</code>，具体过程就不用代码说明了，最后会找到每一个信号的处理函数，问题是这个怎么找到？</p>

<p>还记得在上文提到的task_struct吗，里面有一个成员变量<code>sighand_struct</code>就是用来存储每个信号的处理函数的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct sighand_struct {
</span><span class='line'>  atomic_t        count;  /* 引用计数 */
</span><span class='line'>  struct k_sigaction  action[_NSIG]; /* 存储处理函数的结构 */
</span><span class='line'>  spinlock_t      siglock;    /* 自旋锁 */
</span><span class='line'>  wait_queue_head_t   signalfd_wqh;   /* 等待队列 */
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>struct k_sigaction {
</span><span class='line'>  struct sigaction sa;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct sigaction {
</span><span class='line'>  __sighandler_t  sa_handler;
</span><span class='line'>  unsigned long   sa_flags;
</span><span class='line'>  sigset_t    sa_mask;    /* mask last for extensibility */
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>其中<code>sa_handler</code>就指向了信号的处理程序。</p>

<h2>为某个信号注册处理函数</h2>

<p>Linux提供了修改信号的处理函数的system call，具体如何使用这些system call不是本文的重点，如果你有兴趣可以参考《Computer System: A programmer&rsquo;s perspective》8.5节或者参考资料[6]，里面提供了非常详细的例子。</p>

<h2>总结</h2>

<p>这篇文章基于Linux 3.16.3讲述了从shell敲下<code>kill -9 &lt;PID&gt;</code>后整个系统发生了什么。主要涉及从用户态的shell程序开始，执行coreutils中kill，之后陷入到内核代码，分析了相关的数据结构，信号产生和传递的原理以及核心代码。</p>

<h2>参考</h2>

<p>[1] <a href="http://en.wikipedia.org/wiki/Unix_signal">http://en.wikipedia.org/wiki/Unix_signal</a><br>
[2] <a href="http://stackoverflow.com/questions/1860175/how-does-a-process-come-to-know-that-it-has-received-a-signal">http://stackoverflow.com/questions/1860175/how-does-a-process-come-to-know-that-it-has-received-a-signal</a><br>
[3] <a href="http://www.linuxjournal.com/article/3985">http://www.linuxjournal.com/article/3985</a><br>
[4] <a href="http://blog.csdn.net/walkingman321/article/details/6167435">http://blog.csdn.net/walkingman321/article/details/6167435</a><br>
[5] <a href="http://blog.csdn.net/morphad/article/details/9236975">http://blog.csdn.net/morphad/article/details/9236975</a><br>
[6] <a href="http://www.alexonlinux.com/signal-handling-in-linux">http://www.alexonlinux.com/signal-handling-in-linux</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Javascript中的继承]]></title>
    <link href="http://zyearn.github.io/blog/2015/02/08/understanding-inheritance-in-javascript/"/>
    <updated>2015-02-08T12:30:00+01:00</updated>
    <id>http://zyearn.github.io/blog/2015/02/08/understanding-inheritance-in-javascript</id>
    <content type="html"><![CDATA[<p>在学习Javascript的过程中，哪个部分最隐涩难懂？就我个人而言，是基于原型链的继承机制。它和普通的OO语言如C++、Java中的继承在语法上相似，但内部实现则不同。Javascript里没有“类”的概念，熟悉C++、Java的同学要问了，没有类的话那哪来的继承呢？需要理解Javascript中的继承。首先得理解原型链。</p>

<!-- more -->


<h2>原型链</h2>

<p>当年Javascript被Brendan Eich设计的目标之一就是简单，它只需要能在浏览器上做一些简单的判断和交互即可。如果引入了类，那这门语言就太复杂了。但还是需要一种方法来使对象和对象之间可以串起来，于是就诞生了原型链。那原型链到底是什么意思呢，简单来说，假设我想让B继承A，那么在Javascript中只需要设置B的原型为A即可，A自己也有它的原型，那么就构成了一个“原型链”。</p>

<p>更准确一点，我们来看一些代码。当时C++和Java都用new来新建一个类的instance，会调一个所谓的“构造函数”，Brendan Eich也沿袭了这个思想。因为没有类，new后面应该加什么名字呢，他决定加构造函数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">Chinese</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码定义了一个构造函数，它同时也是一个object（Javascript中所有东西都是object）。new一下这个构造函数会产生一个Chinese实例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">personA</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Chinese</span><span class="p">(</span><span class="s2">&quot;bob&quot;</span><span class="p">);</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">personA</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在新问题来了，我们要为Chinese类加一个皮肤颜色的方法，好像这样就可以办到：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">Chinese</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">skin</span> <span class="o">=</span> <span class="s2">&quot;yellow&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样的结果就是所有的Chinese实例都会拥有一份skin的实例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">personA</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Chinese</span><span class="p">(</span><span class="s2">&quot;bob&quot;</span><span class="p">);</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">personB</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Chinese</span><span class="p">(</span><span class="s2">&quot;Alice&quot;</span><span class="p">);</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">personA</span><span class="p">.</span><span class="nx">skin</span><span class="p">)</span> <span class="c1">// yellow</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">personB</span><span class="p">.</span><span class="nx">skin</span><span class="p">)</span> <span class="c1">// yellow</span>
</span><span class='line'>
</span><span class='line'><span class="nx">personA</span><span class="p">.</span><span class="nx">skin</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span><span class="p">;</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">personA</span><span class="p">.</span><span class="nx">skin</span><span class="p">)</span> <span class="c1">// black </span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">personB</span><span class="p">.</span><span class="nx">skin</span><span class="p">)</span> <span class="c1">// yellow</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以这种方式有一个缺点，Chinese类无法共享一个共有的属性和方法。我们希望有一个类似于“基类”的东西，所有中国人都可以共享这个基类对象。为了解决这个问题，Brendan Eich决定为构造函数设置一个prototype的属性（它是一个object），把所有需要让实例共享的属性和方法都放到prototype这个object里头去，这个prototype叫做实例的原型。实例对象一旦创建，将自动那个引用到构造函数的prototype对象。也就是说，一个实例的属性和方法有两种，一种是本地的，一种是原型的。还是上面的例子，然后把skin放到Chinese.prototype当中去：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">Chinese</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">Chinese</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">skin</span> <span class="o">=</span> <span class="s2">&quot;yellow&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>之后访问实例的skin对象，javascript会先在本地属性中查找，若没有，则取原型中找。在这个例子中，在原型（也就是Chinese.prototype）中，找到了skin方法，所以如果想要修改所有Chinese实例的skin属性就非常容易了（好吧，就想象一下突然基因突变&hellip;），只要修改Chinese.prototype即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">personA</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Chinese</span><span class="p">(</span><span class="s2">&quot;bob&quot;</span><span class="p">);</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">personB</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Chinese</span><span class="p">(</span><span class="s2">&quot;Alice&quot;</span><span class="p">);</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">personA</span><span class="p">.</span><span class="nx">skin</span><span class="p">)</span> <span class="c1">// yellow</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">personB</span><span class="p">.</span><span class="nx">skin</span><span class="p">)</span> <span class="c1">// yellow</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Chinese</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">skin</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span><span class="p">;</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">personA</span><span class="p">.</span><span class="nx">skin</span><span class="p">)</span> <span class="c1">// black </span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">personB</span><span class="p">.</span><span class="nx">skin</span><span class="p">)</span> <span class="c1">// 此时输出的是black，而不是上例中的yellow</span>
</span></code></pre></td></tr></table></div></figure>


<p>写到这里，有一个很自然的问题，实例能不能随意修改它的原型对象？答案是能也不能。假如typeof(原型属性)不是object（比如数字，字符串），那么不可修改；否则（比如[], {}），则能修改。</p>

<p>在Javascript中，是用原型来实现所谓的“继承”，一旦你理解了原型链，那么就几乎理解了Javascript中的继承。</p>

<h2>构造函数的继承与非构造函数继承</h2>

<p>理解了原型链，就可以讲javascript中的继承机制了。关于这两个主题，在搜索资料的时候发现<a href="http://www.ruanyifeng.com/">阮一峰</a>在他的两篇文章里写得已经非常清楚了：
<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html">构造函数的继承</a>和
<a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html">非构造函数的继承</a></p>

<h2>参考</h2>

<p>[1] <a href="http://book.douban.com/subject/3590768/">JavaScript语言精粹</a><br />
[2] <a href="http://www.ruanyifeng.com">http://www.ruanyifeng.com/</a><br />
[3] <a href="http://blog.vjeux.com/2011/javascript/how-prototypal-inheritance-really-works.html">http://blog.vjeux.com/2011/javascript/how-prototypal-inheritance-really-works.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从一个外包项目中学到的]]></title>
    <link href="http://zyearn.github.io/blog/2014/12/30/learn-from-a-outsourcing-project/"/>
    <updated>2014-12-30T23:36:00+01:00</updated>
    <id>http://zyearn.github.io/blog/2014/12/30/learn-from-a-outsourcing-project</id>
    <content type="html"><![CDATA[<p>最近和一位大神同学做了一个网站外包项目，最近结束了，现在稍微总结一下。后台是用nodejs的express写的（话说express的作者认为express不好，然后又去发起了一个新的开源框架叫koa），对用node做web开发也有了一个地图式的了解。</p>

<h3>哪一层解决问题很重要。</h3>

<!-- more -->


<p>举个数据库的例子。</p>

<p>学数据库理论都学过外键，简单来说就是一张表一行的某一项数据依赖于另一张表一项的数据。比如说用户信息有一列叫居住地，而居住地又存在另外一张表里，这时候，用户表的居住地就是个外键，指向居住地表的某一行。</p>

<p>那这个有什么用呢？外键提供了不同等级的约束。比如有一个场景，应用层想删除一个地方，但是如果这个地方有人住的话，就要删除失败，否则这个人就没地方住了。如果没有外键，那么解决办法是先select一下用户表，把所有人的居住地找出来，比对一下将要删除的居住地，发现有了，就删除失败，否则就跑去居住地表删数据。这里涉及了两次DB的读取，非常麻烦和不清晰，给应用层加了很多困难。理论上，应用层应该不管这些东西，直接delete，成功了就返回success，失败就返回一个error_code。</p>

<p>外键就可以完美解决这个问题。外键的RESTRICT约束保证了假如有用户表有一行的某个数据指向了居住表的某一行，那这一行就无法被删除。除了RESTRICT约束，还有别的可以选择，比如CASCADE约束，它的意思是如果被引用的数据删了，那么引用它的数据也同样被删掉。在我们的例子里，如果某个居住地被删了，那么住在这个地方的人也都被删了。选择哪种约束完全看场景需求了。</p>

<p>但外键也不是处处能用的，比如在互联网场景下，用户大并发高，外键的存在可能使数据库成为瓶颈。</p>

<p>关于更多外键的实战应用，也可以参考我的小伙伴专门写了一篇<a href="http://zhoutall.com/archives/617">文章</a>。</p>

<p>除了外键，还有个例子。如果一张表的非key列不能重复，可以在应用层用很dirty的方法解决，比如先读一次，如果要插入的数据已经在了，返回错误；否则插入。在DB层可以很好地解决，只要加个unique key就可以了。</p>

<h3>callback hell</h3>

<p>一上手写node，不用第三方库，只要逻辑逻辑稍微复杂一点，就会出现回调里再回调，之后再回调&hellip;代码里有好几层回调。在这个项目中我们首页的展示依赖于很多块数据，而这些数据是不同回调函数的结果，这时候要等全部的数据来了再渲染首页。还有个场景，有n个回调函数，第i-1个回调的输出是第i个回调的输入。在上面两个情况下如果不用第三方库都会给代码编写调试和以后的维护带来极大的困难。</p>

<p>还好，很多node的第三方库解决了这个问题。比如主流的async，then.js，Promise，async用起来最简单，只是在callback上加了语法糖。then.js的链式API更流畅。出于易用性，我们选择了async，用法简单，刚好能解决我们的大部分需求。</p>

<h3>开发最后的20%会花掉80%的时间</h3>

<p>因为这个项目是全程由我和我的小伙伴做的，所以我们要涉及很多除了开发以外的工作，与人的沟通。（上次Bjarne Stroustrup来学校做讲座的时候，他说的一句话让我记忆深刻，他说，在大型软件开发中，最困难的不是技术问题，而是people problem）导致最后20%的工作已经不仅仅是开发工作了，和客户的对齐，再修改等等会花掉大量的时间。所以不要天真地以后代码打完了就结束了，还有大量的非开发工作等着。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何访问NAT后的server]]></title>
    <link href="http://zyearn.github.io/blog/2014/11/17/visit-server-behind-nat/"/>
    <updated>2014-11-17T11:48:00+01:00</updated>
    <id>http://zyearn.github.io/blog/2014/11/17/visit-server-behind-nat</id>
    <content type="html"><![CDATA[<p>最近项目中有一个需求，需要访问NAT后面的一个restful server，这个NAT是由家用路由器产生的。现在的家用路由器都有端口转发的功能，配合上动态dns解析，这个问题就很容易解决。但是现在问题来了，我们面向的客户是普通用户，对他们而言路由器可能就是透明的，更别说要配置路由器了。所以我们得想其它不让用户参与的解决方案。</p>

<!-- more -->


<p>把问题再说得清楚一些：NAT后面有一台设备，运行着linux，restful server跑在这台设备上，我们需要的做的是使它向外界暴露一个特定的ip和port，外网直接可以对这个ip和port进行请求(我们用curl)。问题大概是下面这个图的样子：</p>

<p><img src="http://zyearnpic.qiniudn.com/nat_rest.png" /></p>

<p>为了解决这个问题，大致有三种思路：</p>

<h2>NAT打洞</h2>

<p>关于NAT打洞的细节请参考之前写的<a href="http://zyearn.github.io/blog/2014/07/19/how-p2p-in-symmetric-nat/">这篇博文</a>。思路貌似很简单，在路由器转发表上打个洞，然后所有对这个port的请求都会转发到NAT后的server上。但这是个不能用的方案。</p>

<p>为什么不能用？考虑symmetric NAT的情况，这是四种NAT类型中最严格的一种，只要解决了这一种，那么NAT打洞就可以用。symmetric NAT的问题在于打完洞了以后这个洞两端的ip和port这四个值需要全部确定，restful server没问题，局域网ip和80端口都不变，但外网无法保证每次都用一个port，比如说curl命令，你无法保证curl每次都用相同的port来发请求。因为这个致命问题所以这个方法不能用。</p>

<h2>ssh反向隧道</h2>

<p>这个方法网上资料很多。总结来说，需要一台公网服务器来做relay，比如ip是120.120.120.120。在内网机器上运行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh -g -N -f -R 12345:127.0.0.1:80 -p 22 root@120.120.120.120</span></code></pre></td></tr></table></div></figure>


<p>12345是120.120.120.120的端口，然后访问120.120.120.120上的12345端口，都被重定向到本机的80端口。</p>

<p>但是这个方法不太稳定，连接一直会断，有一些工具来保证稳定性，比如autossh。</p>

<h2>长连接，请求转发</h2>

<p>因为我们对ssh反向隧道内部详细机制和代码不了解，并且稳定性等等方面考虑的原因，打算自己写了一个类似的工具。其实道理很简单，比如公司需要开发一个网络程序，如果对libevent内部机制和代码不熟悉，谁敢用？出了事谁负责？所以现在很多公司都有自己的网络通信库。开源工具的特点是要满足大众，导致了每个功能可能都很平庸，而如果能自己写工具则能针对公司的业务特点来有所侧重。</p>

<p>ssh反向隧道的本质是长连接+请求转发，所以我们也要实现个类似的东西。需要多加两个模块：</p>

<ol>
<li>Nat后面需要有一个client</li>
<li>需要一个公网服务器来跑relayServer</li>
</ol>


<p>client和relayServer之间通过长连接保持连接。relayServer暴露一个publicip和port，外界通过这个publicip和port请求relayServer。relayServer接受到请求之后，把请求通过长连接转发给NAT后面的client，client收到请求以后再访问同一网段的restful server。这样，我们对publicip:port请求，就等于对NAT内的restful server请求。</p>

<p>架构变为下图所示：</p>

<p><img src="http://zyearnpic.qiniudn.com/nat_rest_2.png" /></p>

<h3>实现</h3>

<p>因为开发进度和难度等因素的考虑，我们选择了nodejs(关于node的优点和介绍在<a href="http://zyearn.github.io/blog/2014/03/25/node-glance/">这篇文章</a>里)来实现这个工具。最好的当然是C，效率上最高，但需要自己写网络库或者用第三方的网络库，而且不能现场调试，所以还是放弃了。</p>

<p>如何维持长连接？</p>

<p>虽然node有内置的net库，但不能保证high availability。所以要选择一个第三方已经包装好的连接库，能断线重连和错误处理的。我们选择了socket.io来实现这个长连接，好像有点大材小用的感觉。</p>

<p>最后这个代码放在了<a href="https://github.com/zyearn/vsbnat">github</a>上，这个代码对NAT后的所有server适用，不一定要是restful server，只要是在内网的server，有ip和port进行访问，都可以用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为多说增加评论推送]]></title>
    <link href="http://zyearn.github.io/blog/2014/09/14/add-noti-to-duoshuo/"/>
    <updated>2014-09-14T10:30:00+02:00</updated>
    <id>http://zyearn.github.io/blog/2014/09/14/add-noti-to-duoshuo</id>
    <content type="html"><![CDATA[<p>先说下为什么会有这篇文章。</p>

<p>曾经在搭博客的时候，使用的是disqus作为评论插件，使用了一阵后发现它有两个缺点，首先，它的加载速度非常慢，其次，很多人都没有disqus账号导致要注册才能评论。于是想找个本土化的评论系统，满足我的加载速度要求和可以通过社交平台账号登陆然后评论的要求。</p>

<!-- more -->


<p>调查下来发现<a href="http://duoshuo.com/">duoshuo</a>这款评论插件比较符合，速度快，社交网站登录，还提供邮件提醒功能，就决定用它了！</p>

<p>问题很快就出现了，多说只有在一个用户第一次评论完，另外一个用户回复第一个用户的时候，才会有邮件通知说“xxx回复了你”，也就是说如果不点“回复某人”的按钮，而直接留言，多说是不会邮件提示你有留言了。不知道多说为什么不解决这个问题，流量太大不好解决？反正让人很不舒服。</p>

<p>那就让我们来解决这个问题。调查了下，大概有下面两种思路：</p>

<ol>
<li>调用duoshuo的API</li>
<li>爬下duoshuo的admin页面，里面有admin的所有评论</li>
</ol>


<h2>调用duoshuo的API</h2>

<p>多说开放了获取某一篇文章评论的API，但这个API有个限制就是这篇文章一定要有个unique key才能获取。而这个unique key本身就是可有可无的，我现在所有的文章都没有这个key。如果要用API的话，要给所有的文章加上这个key，还得保证以后所有的文章都要自动生成这个key，当然手动也可以，就是太麻烦。</p>

<p>更麻烦的是，对于每篇新的文章，我都要在调API的地方注册这个新的key，之后才会获取到这篇文章的评论。太麻烦了，放弃这种方法。</p>

<h2>爬虫</h2>

<p>登录多说的admin页面，会发现所有的评论都列在页面上，那直接把它们爬下来不就行了。定时运行爬虫脚本，如果这次爬的评论数比上次爬的多，那么说明有新的评论。</p>

<p>这里的爬虫是用nodejs写的，因为它发起一个自定义header的get请求实在太容易了。具体应该发什么，在浏览器中打开审查元素看一下浏览器发送请求带了哪些header就可以。admin页面如果不设置cookie是无法登录的，所以这里我们要模拟浏览器设置cookie来发送GET请求。马上试了下，发现爬下来的页面什么都没有，定神再看，它的评论列表是通过ajax拿到然后通过jquery的插件画出来的。</p>

<p>于是问题就变成了，模拟发送这个ajax，然后分析返回数据得出评论数，和上一次的结果比较，若大于，则有新评论。好，开始写程序，header比较重要，正确设置好cookie才能拿到数据，在我浏览器中是下面这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var options = {
</span><span class='line'>    hostname: 'zyearn.duoshuo.com',
</span><span class='line'>    port: 80,
</span><span class='line'>    path: '/api/posts/list.json?order=desc&source=duoshuo%2Crepost&max_depth=1&limit=30&related%5B%5D=thread&related%5B%5D=iplocation&nonce=xxxxxxxx&status=all',
</span><span class='line'>    headers:{
</span><span class='line'>        'Connection': 'Close',
</span><span class='line'>        'Cache-Control': 'max-age=0',
</span><span class='line'>        'Accept': 'application/json, text/javascript, */*; q=0.01',
</span><span class='line'>        'Referer': 'http://zyearn.duoshuo.com/admin/',
</span><span class='line'>        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.143 Safari/537.36',
</span><span class='line'>        'Accept-Language': 'zh-CN,zh;q=0.8',
</span><span class='line'>        'Accept-Charset': 'utf-8',
</span><span class='line'>        'Cookie': 'duoshuo_unique=xxxx; PHPSESSID=xxxx'
</span><span class='line'>    }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>返回的是一个json数据，其中有一个域值正好是评论数，拿到以后和原来的比较即可。还需要保存上一次运行的评论数结果，我将它保存在一个文件中，每次去读取。</p>

<h3>推送</h3>

<p>既然我们已经知道了是否有新的评论，那么就要推送给用户，这里提供两个方案，短信和邮件。</p>

<h4>短信推送</h4>

<p>飞信提供了一个免费的命令行工具，能通过它来发送短信。具体教程请参考<a href="http://bbs.it-adv.net/viewthread.php?tid=1081">这里</a>;</p>

<h4>邮件推送</h4>

<p>Mutt是一个命令行邮件发送工具，能达到我们的目的，设置请参考我的<a href="http://wiki.zyearn.com/tool/mutt.html">wiki</a>。</p>

<h3>设置cron</h3>

<p>因为这是一个定时运行的脚本，所以要设置crontab任务。在cron中加入下列代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*/1 * * * * /usr/local/sbin/node /root/duoshuo/duoshuoCrawler.js</span></code></pre></td></tr></table></div></figure>


<p>意思是每隔1分钟去检查一下是否有新评论，如果你的服务器压力太大，可以把时间改长。</p>

<p>至此，我们的推送功能就开发好了。全部的代码已经放在了<a href="https://github.com/zyearn/duoshuo--notification">github</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[服务器推送技术]]></title>
    <link href="http://zyearn.github.io/blog/2014/08/13/server-push-nodejs/"/>
    <updated>2014-08-13T23:06:00+02:00</updated>
    <id>http://zyearn.github.io/blog/2014/08/13/server-push-nodejs</id>
    <content type="html"><![CDATA[<p>服务器推送技术在现时代的网站中越来越流行，比如说，在你刷着微博的时候，有好友私信你，这时候后台的消息会实时推送到前台，在不刷新页面的前提下提示用户这条消息，显然这条消息是被“推”到客户端的，那么这个是怎么实现的呢？</p>

<!-- more -->


<h2>推送技术</h2>

<p>一般的服务器Push技术包括：</p>

<ol>
<li><p>基于 AJAX 的长轮询（long-polling）方式，服务器Hold一段时间后再返回信息，然后前端再往后端发起请求，以此往复</p></li>
<li><p>HTTP Streaming，通过iframe和script标签完成数据的传输，这种方法近来已经很少被使用</p></li>
<li><p>TCP 长连接</p></li>
<li><p>HTML5新引入的WebSocket，可以实现服务器主动发送数据至网页端，它和HTTP一样，是一个基于HTTP的应用层协议，跑的是TCP，所以本质上还是个长连接，双向通信，意味着服务器端和客户端可以同时发送并响应请求，而不再像HTTP的请求和响应</p></li>
</ol>


<p>上述的1和2统称为comet技术，这里有个简单的介绍：<a href="http://www.ibm.com/developerworks/cn/web/wa-lo-comet/">Comet：基于 HTTP 长连接的“服务器推”技术</a></p>

<h2>socket.io</h2>

<p>前些日子由于项目网站的需求，后台会产生一些提示用户的警告消息，为了实现在用户正常浏览网页的前提下，后台通知实时推送到前端显示。</p>

<p>综合调研下来，发现是nodejs的socket.io比较成熟地解决了这件事情。它是一个实时通信的框架，天生就是为了服务器端和客户端的双向通信。在它的<a href="http://socket.io/">官网</a>上，提供了一些最简单的应用，其中一个就是多人在线聊天室，用socket.io实现的代码逻辑非常清楚。</p>

<p>socket.io是WebSocket的一个开源实现，对不支持websocket的浏览器降级成comet / ajax轮询，socket.io的良好封装使代码编写非常容易。</p>

<h2>socket.io的部署</h2>

<p>它的部署方案极其简单，结合express框架，按照官网文档，几行代码就实现了一个实时通信server。它和Nginx/apache共存，原来的服务器还是提供原来的功能，新增的这台实时通信server只负责消息的推送。</p>

<p>需要连上这台server也很简单，需要在前端js中加入:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;script src="http://zyearn.github.io/socket.io/socket.io.js"&gt;&lt;/script&gt;
</span><span class='line'>&lt;script&gt;
</span><span class='line'>  var socket = io.connect('http://&lt;serverIP&gt;:&lt;port&gt;');
</span><span class='line'>&lt;/script&gt;</span></code></pre></td></tr></table></div></figure>


<p>实际上，利用服务器推送技术，我们能实现好多平常HTTP协议无法办到的事情。</p>

<h2>移动端的实时推送</h2>

<p>上述所讨论的所有东西都是Web端的实时通信，未来是属于移动端的，显然移动端的实时推送也非常重要。</p>

<p>在移动端主要有以下两个技术：XMPP 和 MQTT，有兴趣的同学可以自己去了解一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[博客前端性能优化]]></title>
    <link href="http://zyearn.github.io/blog/2014/08/05/optimize-website/"/>
    <updated>2014-08-05T21:08:00+02:00</updated>
    <id>http://zyearn.github.io/blog/2014/08/05/optimize-website</id>
    <content type="html"><![CDATA[<h2>缘由</h2>

<p>以前给主页index加了各种统计，字体，微博秀后，主页的载入速度实在太慢，加上本身的博客框架也需要优化，一直都没有时间做（其实是懒），最近终于受不了了，想要把主页的加载速度加快。这个博客的后台操作几乎没有，服务器是github pages，评论用的是第三方插件，所以优化余地只有前端。</p>

<!-- more -->


<h2>评分</h2>

<p>有一个很好的工具叫做<a href="http://gtmetrix.com/">gtmetrix</a>，这个网站能够根据你的网站提供一份评分和详细的优化策略，本网站在优化前的评分是这样的：</p>

<p><img src="http://zyearnpic.qiniudn.com/before-opt.jpg" /></p>

<p>Waterfall是这个样子的：</p>

<p><img src="http://zyearnpic.qiniudn.com/pitfall.jpg" /></p>

<h2>优化</h2>

<h3>Recommendation 1: Remove query strings from static resources</h3>

<p>这个没办法，query string是cnzz统计和微博识别我的唯一途径。而且若首页加入了微博秀，会有好几个带query string的http request。解决方案就是直接把微博秀给删了。</p>

<h3>Recommendation 2: Leverage browser caching</h3>

<p>这个的意思是，一些可以缓存的静态资源expire时间太短，导致短时间内刷新需要重复加载。因为我用的是github pages，所以我去查了下怎么搞定这件事，结果stackoverflow上有个相同的<a href="http://stackoverflow.com/questions/14798589/github-pages-http-headers">问题</a>，结论就是目前还不提供修改http header的方法。</p>

<h3>Recommendation 3: Defer parsing of JavaScript</h3>

<p>浏览器对js的执行规则是，读到一个js文件就执行这个js文件，导致如果你把js文件放在html的head里的话，浏览器在构建DOM之前忙着执行js了，结果就是用户体验极差。正确的做法是先加载页面，然后再执行js。</p>

<p>一个有效的措施是把js放到页面的最下面，本博客用的是octopress框架，本身自带两个js，加上jquery，一个三个js文件，默认放在了head里，于是我把它放到了页面底端。</p>

<h3>Recommendation 4: Inline small CSS</h3>

<p>把一些小的css文件直接inline在html里。</p>

<h3>Recommendation 5: Optimize images</h3>

<p>这里说的是图片的压缩，这个图片主要来源是新浪的微博秀和多说的最近评论。后来干脆把它们全部删掉了。</p>

<h3>Recommendation 6: Avoid landing page redirects</h3>

<p>我把www.zyearn.com重定向到了zyearn.com，目的就是为了不让两个地址的A记录同时解析到同一个ip，防止搜索引擎认为这是两个网站，所以这条忽略。</p>

<h3>Recommendation 7: Use a Content Delivery Network (CDN)</h3>

<p>感觉没什么必要，静态文件不是很多，而且放在国内的cdn上国外访问就慢了。曾经把jquery换到了新浪的国内cdn，结果测下来国外访问太慢，还是换回了谷歌的cdn。</p>

<h3>Recommendation 8: Make fewer HTTP requests</h3>

<p>网上的建议是把若干个js合并成一个大的js，这样在组织结构上显然不好，牺牲一点点速度换来结构的清晰还是很有必要的，所以不合并了。</p>

<p>为了减少非必要的网络流量，网站以前用了两个字体，正文一个字体，标题一个字体，共500K，在拥堵网络环境下，很多时候都是网页加载好了，但字体还在加载，导致用到那个字体的地方的文字就显示不出来，于是干脆把花哨的字体全删了，默认的也挺好。</p>

<p>另外，好多问题都是由第三方插件引起的，比如首页的cnzz统计，微博秀，duoshuo的最近评论，除了统计留着其它的第三方都删掉了。</p>

<h2>优化结果</h2>

<p>这是优化后的waterfall：</p>

<p><img src="http://zyearnpic.qiniudn.com/pit-fall-after.jpg" /></p>

<p>可以看出页面页面加载只有几百毫秒，从原来的29个请求降到了12个请求。图下方耗时的都是cnzz的东西了，不过这些都是发生在页面加载之后。实际上这是在国外测的速度，cnzz会显得慢一些，在国内cnzz的访问还是非常快的。</p>

<p>现在打开主页基本上不会有卡顿，目的基本实现了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在symmetric NAT中怎么实现p2p]]></title>
    <link href="http://zyearn.github.io/blog/2014/07/19/how-p2p-in-symmetric-nat/"/>
    <updated>2014-07-19T22:56:00+02:00</updated>
    <id>http://zyearn.github.io/blog/2014/07/19/how-p2p-in-symmetric-nat</id>
    <content type="html"><![CDATA[<p>最近在研究NAT穿越实现p2p技术，这个技术有很多广泛的应用，比如大家最熟悉的qq是怎么实现点对点传输文本的？A在一个局域网里，B在一个局域网里，他们怎么实现通信？这当中有什么困难？除了qq，一般的IM软件都有遇到这个问题，比如skype和facetime。一些下载软件也运用了p2p技术，就是边下载边上传文件块给那些没有这块文件的人，这个技术也要涉及NAT穿越。</p>

<p>详细说之前，我们先说说背景知识。</p>

<!-- more -->


<h2>背景知识之一：什么是NAT</h2>

<p>NAT（Network Address Translation）是将IP 数据包头中的IP 地址转换为另一个IP 地址的过程，通俗来讲，就是局域网，公用一个public IP。那为什么要有这个东西，NAT是用来解决什么问题的？</p>

<p>时光回到上个世纪80年代，当时的人们在设计网络地址的时候，觉得再怎么样也不会有超过32bits位长即2<sup>32</sup>台终端设备联入互联网，再加上增加ip的长度（即使是从4字节增到6字节）对当时设备的计算、存储、传输成本也是相当巨大的，想象当年的千年虫问题就是因为不存储年份的前两位导致的，现在想想，不就几个byte吗？我一顿饭不吃就省了好几个G了，但在当时的确是相当稀缺的资源。</p>

<p>后来逐渐发现IP地址不够用了，然后就NAT就诞生了！（虽然ipv6也是解决办法，但始终普及不开来，而且未来到底ipv6够不够用，谁知道呢）。NAT的本质就是让一群机器公用同一个IP。这样就暂时解决了IP短缺的问题。其实NAT还有一个重要的用途，就是保护NAT内的主机不受外界攻击。</p>

<h2>背景知识之二：什么是p2p</h2>

<p>p2p（peer to peer）可以定义成终端之间通过直接交换来共享计算机资源和服务，而无需经过服务器的中转。它的好处是显而易见的，不用服务器中转，不需要受限于服务器的带宽，而且大大减轻了服务器的压力。p2p的应用包括IM（qq，MSN），bittorrent等等。</p>

<h2>为什么要NAT穿越</h2>

<p>要实现p2p，我们要克服的就是NAT穿越。在现在的互联网环境下，一个终端一般都在一个NAT内，NAT会有一个网关路由，对外暴露一个public IP，那么两个都在NAT的终端怎么通信呢？我们不知道对方的内网IP，即使把消息发到对方的网关，然后呢？网关怎么知道这条消息给谁，而且谁允许网关这么做了？</p>

<h2>一个容易的问题</h2>

<p>NAT内的设备怎么和公网服务器通信？</p>

<p>假设路由器ip为<code>1.2.3.4</code>，公网服务器ip为<code>5.6.7.8</code>，内网机器<code>192.168.0.240:5060</code>首先发给路由器<code>1.2.3.4</code>，路由器分配一个端口，比如说54333，然后路由器代替内网机器发给服务器，即<code>1.2.3.4:54333 -&gt; 5.6.7.8:80</code>，此时 路由器会在映射表上留下一个“洞”，来自<code>5.6.7.8:80</code>发送到<code>1.2.3.4</code>的54333端口的包都会转发到<code>192.168.0.250:5060</code></p>

<p>但不是所有发往1.2.3.4:54333的包都会被转发过去，不同的NAT类型有不同的做法。下面我们来看几种NAT的类型：</p>

<h2>NAT类型之一：Full Cone</h2>

<p>全锥形NAT</p>

<p>IP、端口都不受限。只要客户端由内到外打通一个洞之后（NatIP:NatPort -> A:P1），其他IP的主机(B)或端口(A:P2)都可以使用这个洞发送数据到客户端。</p>

<p>(图片均来自网络)
<img src="http://zyearnpic.qiniudn.com/full%20cone.png" alt="full cone" /></p>

<h2>NAT类型之二：Restricted Cone</h2>

<p>受限锥形NAT</p>

<p>IP受限，端口不受限。当客户端由内到外打通一个洞之后(NatIP:NatPort -> A:P1)，A机器可以使用他的其他端口（P2）主动连接客户端，但B机器则不被允许。</p>

<p><img src="http://zyearnpic.qiniudn.com/Restricted%20Cone.png" alt="recone" /></p>

<h2>NAT类型之三：Restricted Port Cone</h2>

<p>端口受限锥型</p>

<p>IP、端口都受限。返回的数据只接受曾经打洞成功的对象（A:P1），由A:P2、B:P1发起的数据将不被NatIP:NatPort接收。</p>

<p><img src="http://zyearnpic.qiniudn.com/Restricted%20Port%20Cone.png" alt="pcone" /></p>

<h2>NAT类型之四：Symmetric NAT</h2>

<p>对称型NAT</p>

<p>对称型NAT具有端口受限锥型的受限特性。但更重要的是，他对每个外部主机或端口的会话都会映射为不同的端口（洞）。只有来自相同的内部地址（IP:PORT）并且发送到相同外部地址（X:x）的请求，在NAT上才映射为相同的外网端口，即相同的映射。</p>

<p>举个例子：</p>

<ol>
<li>client访问A:p1是这样的路径：<code>Client --&gt; NatIP:Pa1 --&gt; A:P1</code></li>
<li>client访问A:p2是这样的路径：<code>Client --&gt; NatIP:Pa2 --&gt; A:P2</code></li>
</ol>


<p>(而在前面的三种NAT中，只要client不变，那么留在路由器上的“洞”就不会变，symmetric NAT会变，端口变)</p>

<h2>怎么确定自己的NAT类型</h2>

<p>为什么要知道自己的NAT类型？这为之后的打洞做准备。RFC专门定义了一套协议来做这件事（RFC 5389），这个协议的名字叫STUN（Session Traversal Utilities for NAT），它的算法输出是:</p>

<ol>
<li>Public ip and port</li>
<li>防火墙是否设置</li>
<li>是否在NAT之后以及NAT的类型</li>
</ol>


<p><img src="http://zyearnpic.qiniudn.com/STUN.png" alt="turn" width="280" height="360"></p>

<h2>穿透(打洞)策略</h2>

<p>问题：有两个需要互联的client A和client B</p>

<p>方案：</p>

<ol>
<li>A、B分别与stun server交互获得自己的NAT类型</li>
<li>A、B连接一个公网服务器（turn server，RFC5766），把自己的NAT发给turn server，此时turn server发现A和B想要互连，把对方的ip，port，NAT类型发给对方</li>
<li>Client根据自身NAT类型做出相应的策略。</li>
</ol>


<p><img src="http://zyearnpic.qiniudn.com/turn.png" alt="stun" width="280" height="360"></p>

<h3>If {有一方对称NAT}</h3>

<p>因为每一次连接端口都不一样，所以对方无法知道在对称NAT的client下次用什么端口。
无法完全实现p2p传输（预测端口除外），需要turn server做一个relay，即所有消息通过turn server转发</p>

<h3>Else if {有一方是Full Cone}</h3>

<p>一方通过与full cone的一方的public ip和port直接与full cone通信，实现了p2p通信。</p>

<h3>Else if {有一方是受限型NAT(两种)}</h3>

<p>受限型一方向对方发送“打洞包”，比如”punching…”，对方收到后回复一个指定的命令，比如”end punching”，通信开始。这样做理由：受限型一方需要让IPA:portA的包进入，需要先向IPA：portA发包。实现了p2p通信。</p>

<h2>对称NAT实现p2p的一种方法</h2>

<p>我们通过上述的讨论可知，symmetric NAT好像不能实现p2p啊？其实不然，能实现，但代价太高，这个方法叫端口预测。</p>

<p>基本思路：</p>

<ol>
<li>A向B的所有port(0~65535)发包，让路由器知道来自B的所有端口都转发到A</li>
<li>B向A的所有port(0~65535)发包，让路由器知道来自A的所有端口都转发到B</li>
<li>于是连接完成了</li>
</ol>


<h2>参考资料</h2>

<ul>
<li>webRTC： <a href="http://blog.csdn.net/kl222/article/details/17198873#_Toc381116530">http://blog.csdn.net/kl222/article/details/17198873#_Toc381116530</a></li>
<li>Open source STUN server software：<a href="https://github.com/jselbie/stunserver/wiki">https://github.com/jselbie/stunserver/wiki</a></li>
<li>A Python STUN client for getting NAT type and external IP：<a href="https://github.com/jtriley/pystun">https://github.com/jtriley/pystun</a></li>
<li><a href="https://github.com/node/turn-client">https://github.com/node/turn-client</a></li>
<li><a href="http://think-like-a-computer.com/2011/09/16/types-of-nat/">http://think-like-a-computer.com/2011/09/16/types-of-nat/</a></li>
<li>NAT类型与穿透 及 STUN TURN 协议：<a href="http://nodex.iteye.com/blog/1488719">http://nodex.iteye.com/blog/1488719</a></li>
<li>stun client初试：<a href="http://blog.csdn.net/ga6840/article/details/6187084">http://blog.csdn.net/ga6840/article/details/6187084</a></li>
<li>P2P在NAT和STUN： <a href="http://blog.csdn.net/A1989A132/article/details/17139003">http://blog.csdn.net/A1989A132/article/details/17139003</a></li>
<li><a href="http://bbs.csdn.net/topics/360183462">http://bbs.csdn.net/topics/360183462</a></li>
<li><a href="http://bbs.csdn.net/topics/320164607">http://bbs.csdn.net/topics/320164607</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
