---
layout: post
title: "抽象与计算机课程"
date: 2016-03-06 21:43
comments: true
categories: Thoughts
---

如果要问计算机领域中哪个思想对我的帮助最大，那么应该就是抽象了。本文主要介绍一下抽象（abstraction）以及它和计算机课程的关系。

第一次接触抽象是我大学低年级学数据结构的时候，记得很清楚当时学一个概念叫抽象数据类型（abstract data type），大概意思就是一个数据结构，接口是一回事，实现是另一回事，比如栈，作为使用者你只需要知道它有push、pop、isEmpty等方法，但它的底层实现到底是array还是linked list，你是不需要知道的。
<!--more-->

用通俗一点的话说，抽象就是你好好做自己的事，以及知道别人能帮你干什么事，至于别人是如何帮你完成的，你没必要知道。

这个简单的思想大大提高了开发者的效率，让开发者只专注于要解决的问题，而不是一些细枝末节的事。

孟岩在它的[博客](http://blog.csdn.net/myan/article/details/5877305)里也提到过“关注重点”这件事，虽然没有明显地提及抽象二字，但他的意思和抽象表达的意思是一样的：

> 我主张，在具备基础之后，学习任何新东西，都要抓住主线，突出重点。对于关键理论的学习，要集中精力，速战速决。而旁枝末节和非本质性的知识内容，完全可以留给实践去零敲碎打。
> 原因是这样的，任何一个高级的知识内容，其中都只有一小部分是有思想创新、有重大影响的，而其它很多东西都是琐碎的、非本质的。因此，集中学习时必须把握住真正重要那部分，把其它东西留给实践。对于重点知识，只有集中学习其理论，才能确保体系性、连贯性、正确性，而对于那些旁枝末节，只有边干边学能够让你了解它们的真实价值是大是小，才能让你留下更生动的印象。如果你把精力用错了地方，比如用集中大块的时间来学习那些本来只需要查查手册就可以明白的小技巧，而对于真正重要的、思想性东西放在平时零敲碎打，那么肯定是事倍功半，甚至适得其反。

最近发现，计算机专业的课程完全可以用抽象来解释：每一门课想做的事就是利用下层提供的接口，实现功能，然后再给上层提供接口。这样一层一层的抽象就构成了所有的专业课。

举一个例子来说明这个从上往下的层级抽象是如何组织的。

先来看最高层，问题。刚学编程的时候，会先学一门课导论课或者编程入门课，我当时的入门课叫做“程序设计”，课程内容是介绍一些问题，然后介绍一点编程语言的知识，作业是一些编程问题，比如八皇后、素性测试之类的比较常规的编程题。这门课的目的一般都是介绍“问题”的，介绍不用分支科学有哪些有挑战的问题，让学生对计算机专业有一个感性的认识，而不是对特定编程语言或者算法的学习，所以这类课程一般用python来编程。

再往下一层，算法和数据结构。这一层的目的是学习/实现各种算法/数据结构，提供给上层抽象。比如排序，问题解决者只要知道这里应该用快速排序，而不是选择排序，而把快速排序的实现留给这一层的开发者，从而使各种优化都可以对上层透明，比如小数组变插入排序、中位数取pivot、三向快速排序等，这些优化调用者完全不必要知道，他只需要知道：哇，这个库提供的快速排序还真快。

再往下一层，语言层，毕竟所有算法都要由某一门语言来实现。这一层的存在使得算法的设计可以脱离具体的语言。不同语言又提供了不同的抽象，像函数式语言就比命令式语言的抽象级高，更高的抽象级意味着更加专注问题本身（不需要考虑内存布局、CPU使用等）以及更少的代码量。

再往下一层，编译器/解释器。我们编写代码是用高级语言，而cpu上执行的是机器码，所以这个抽象层帮我们做了这个转化。这个抽象层的好处是，高级代码的编写者完全不需要知道这个程序所运行的操作系统和硬件平台，任何有该语言编译器/解释器的机器，程序都可以跑（从而实现了跨平台）。有这一层的好处是，应用层开发者可以不用知道这个由高级语言到机器码的转化具体是怎么实现的，毕竟编译器优化的编写和优化完全是一个团队的工作量，开发者关注问题的解决，编译器负责转化出高效的机器码，各干各的，这正是抽象的重点。

再往下一层，操作系统。OS向开发者抽象了硬件（CPU、内存、Disk、NIC等），并且以syscall的形式向用户提供服务。OS的设计是最能体现抽象的，虚拟内存和进程让程序以为自己独占着内存和CPU，同时隔离了不同进程以防恶意进程；文件系统让用户可以方便地读取存储数据，而不需要直接操作底层的硬盘；文件描述符抽象了底层的设备（pipe？file？device？socket？）。

再往下一层，ISA（Instruction set architecture），俗称软件与硬件的接口。这个俗称是非常形象的。指令集架构，说得简单点就是机器码，也可以理解为一个协议。ISA标准制定者指定一套指令集（比如x86、PowerPC、SPARC），然后编译器开发者需要根据这个标准/协议来编写对应的编译器；CPU制造商需要根据这个标准/协议来制造出支持这套ISA的CPU（比如intel的CPU支持x86/x86\_64）。也就是说，软件/硬件都依照这个ISA来设计，那么就可以对接了。

再往下一层，组成原理和体系结构。这一层要做的事情是借助数字电路给它提供的抽象（组合电路和锁存器），来设计一个能实现某种ISA的CPU，让编译器生成的指令可以在此CPU上运行。大学里一般会开一门叫“计算机组成原理”的课，一开始学单周期CPU的实现（取指、译码、执行......），为了提高效率又提出了流水线的实现。为了发掘更高的效率，之后又会学一门叫“计算机体系结构”的课，这门课的目的是为了发掘更高的并行，从而制造出更快的CPU。那这一层是如何用数字电路提供的抽象的？举两个典型例子：一、CPU为了做计算会有ALU模块，而ALU模块正是一个组合电路（输入确定那么输出确定）；二、在流水线寄存器中每一个时钟上升沿都会保存输入的值，在这个时钟周期内组合电路会根据这个新值计算出结果传输到下一级流水线寄存器的输入，等待下一个时钟上升沿的到来，这里的流水线寄存器正是某种锁存器的实现，而CPU开发者并不需要这个数字电路模块是怎么实现。

再往下一层，数字电路。这门课的目的是教学生如何利用基本的门电路（与非或门）来实现一些高级的功能（译码器、多路复用器、锁存器、时序电路......），然后给上层提供功能。上数字电路是一个用砖搭房子的过程，由基本的门电路开始，慢慢构造出复杂的电路。数字电路不需要关心基本的门电路是如何实现的，因为这正是模拟电路向上层提供的抽象。

再往下一层，模拟电路。这一层实现了与或非等基本门电路。比如非门、与非门、或非门都可以通过若干个p/n型MOS晶体管构成，而与门可以通过连接一个与非门和非门构成，或门可以通过连接一个或非门和非门构成。很多同学都觉得模电对于计算机的同学不必要学，而我认为相反，它是你构建整个计算机抽象层级的基石。

再往下一层，就不是计算机领域研究的事了。

当然，还有很多专业课我并没有提及，比如网络，它是OS提供的功能，以文件描述符的形式提供给用户使用；在网络协议栈实现的细节里，又分了好几层抽象，这就是我们熟知的OSI七层网络模型（有时候被抽象为五层：Application、Transport、Network、DataLink、Physical）。各位可以自己再回忆一下大学里上过哪些专业课，以及它应该放在抽象的哪一层上。

仔细一想会发现，几乎所有的技术书籍都尝试在解决某一层上的问题，利用下层提供的抽象，然后向上层提供功能。

让我们脱离计算机领域，再往高一点看，会发现整个计算机领域就是在为别的领域提供功能、并隐藏了细节：医疗、交通、餐饮、支付......

抽象，让生活变得更简单了一点。
